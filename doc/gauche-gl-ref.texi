\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-gl-refe.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference: (gauche-gl-refe.info).	Gauche OpenGL binding
@end direntry
@c JP
@setfilename gauche-gl-refj.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference (ja): (gauche-gl-refj.info).	Gauche OpenGL binding
@end direntry
@c COMMON
@comment %**end of header

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche-gl : OpenGL binding for Gauche
@c JP
@title Gauche-gl : OpenGL binding for Gauche
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2012 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
This is a reference manual of Gauche-gl, an OpenGL binding for the
Gauche Scheme implementation.
This manual is for version @VERSION@.
@end ifnottex

@c ======================================================================
@menu
* Introduction::                
* Installation::                
* Getting Started::             
* OpenGL API::                  
* GLUT API::                    
* Vectors and matrices::        
* Simple utilities::            
* Indices::                     
@end menu

@node Introduction, Installation, Top, Top
@chapter Introduction
@c NODE はじめに

Gauche-gl is an extension module of Gauche Scheme implementation.
It provides the following modules:

@table @code
@item gl
This module provides bindings to OpenGL API.
It covers most functions in OpenGL 1.0 through 2.0,
and GLU.   The functions are described in @ref{OpenGL API}.
@item gl.glut
This module provides bindings to most functions in GLUT.
The functions are described in @ref{GLUT API}.
@item gl.math3d
This module provides vector and matrix calculations
optimized for 3D homogeneous coordinates.
The vector and matrix objects here can be directly passed to
Gauche-gl functions.
The functions are descrbied in @ref{Vectors and matrices}.
@item gl.simple.*
These modules provide simple APIs for programmers to
hack up a very simple OpenGL application.  They are by no
means intended for general application development, but
would be handy for throwaway script.
See @ref{Simple utilities} for the details.
@end table

@c ======================================================================
@node Installation, Getting Started, Introduction, Top
@chapter Installation

Installing Gauche-gl is usually straightforward on Unix variants.

You have to have the following programs installed on your machine.
@itemize @bullet
@item
Gauche 0.8.5 or later
@item
OpenGL 1.1 equivalent library; the auther checked with Mesa 3.4
and NVidia's GLX driver.
@item
GLUT 3.7 or later.
@end itemize

The standard way to compile and install Gauche-gl is as follows:
@example
% gzcat Gauche-gl-@VERSION@.tgz | tar xf -
% cd Gauche-gl-@VERSION@
% ./configure
% make
% make test
% make install
@end example

Or you can use @file{gauche-package} command:
@example
% gauche-package install -C=<configure-option> Gauche-gl-@VERSION@.tgz
@end example


The confiugre script figures out the location Gauche is installed,
and install Gauche-gl in the same place.

If you have GLUT installed in non-standard place, you have to
tell the configure script where it is.
@example
% ./configure --with-glut=DIR
@end example

Since version 0.4, Gauche-gl can be configured to include bindings
to NVidia's Cg Toolkit.  The binding code is contributed by Issac Trotts.
To enable Cg binding, give @code{--enable-cg} option to the configure
script.
@example
% ./configure --enable-cg
@end example


It is reported that Mesa in FreeBSD ports is compiled with pthreads
enabled, and Gauche-gl can't be linked unless Gauche itself is
compiled with pthreads.  The configure script of Gauche prints
warning if you specify pthreads, but it is safe as far as you
don't call make-thread in your program.

There are various examples under @file{examples/} directory.
If you want to run the examples before installing Gauche-gl,
you have to tell the location of the library to @code{gosh}
command, e.g. @code{gosh -I../src -I../lib gears.scm}.
Some demos under subdirectories have a shell script that invokes
@code{gosh} with proper command-line options.

@table @file
@item gears.scm
Brian Paul's 3D gear wheels.
@item mandelbrot.scm
Simple calculated texture.
@item glbook/
This subdirectory contains examples found in "OpenGL Programming Guide",
a.k.a. Redbook.  
@item slbook/
This subdirectory contains examples found in "OpenGL Shading Language".
Each demo is under its own subdirectories.  You need to have
proper driver/hardware that supports GLSL to run these demos.
@end table


@c ======================================================================
@node Getting Started, OpenGL API, Installation, Top
@chapter Getting Started

@menu
* GL calls in Scheme::          
* Advanced GL features::        
* Using GLUT::                  
* Performance tips::            
@end menu

@c ----------------------------------------------------------------------
@node GL calls in Scheme, Advanced GL features, Getting Started, Getting Started
@section GL calls in Scheme

I assume you have basic knowledge of OpenGL API.
Gauche-gl maps OpenGL calls to Scheme procedures
pretty straightforwardly.  For example, the very first
example of "OpenGL Programming Guide", the pseudo code
of OpenGL application, can be written in Gauche-gl like
this:

@example
(use gl)

(define (main args)
  (@i{initialize-a-window-please})

  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color 1.0 1.0 1.0)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  (gl-begin* GL_POLYGON
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
    )
  (gl-flush)
  (@i{update-the-window-and-check-for-events})
  0)
@end example

Note that @i{initialize-a-window-please} and
@i{update-the-window-and-check-for-events} are function calls
dependent on the windowing system.  Gauche-gl comes with GLUT
binding and you can use it to do basic stuff.  In the separate
package Gauche-gtk, a binding to GtkGLExt is provided, which allows
you to do GL rendering inside Gtk widgets.

For the time being, let's focus on the pure GL part.

The mapping of GL call name is straightforward.
The mixed case names in OpenGL C API is expanded to hyphenated name,
e.g. @code{glClearColor} @result{} @code{gl-clear-color}.
OpenGL enums are mapped as is, e.g. 
@code{GL_POLYGON}.  (Note that Gauche is case-sensitive by default.
Also note the underscore, not hyphen, in constants).

A few convenience macros, such as @code{gl-begin*}, is defined.
There are straight bindings of @code{gl-begin} and @code{gl-end},
so you can write the drawing part in the same way as in C:
@example
  (gl-begin GL_POLYGON)
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
  (gl-end)
@end example

Actually @code{gl-begin*} macro expands into the above calls.
It's a matter of taste, but the macro version guarantees
begin and end match, and the syntax-aware editor can indent 
internal calls accordingly.

You might have noticed that the type suffix in C API
is not in Gauche binding.  The Scheme function figures out the
type of passed arguments and calls appropriate C API.
SRFI-4 uniform numeric vectors are used to represent
arrays of numbers.

@example
  (gl-vertex 1.0 2.0 3.0)    @result{} glVertex3d
  (gl-vertex '#f32(1.0 2.0)) @result{} glVertex2fv
  (gl-vertex '#s32(3 2 5))   @result{} glVertex3iv
@end example

Generally, passing uniform vectors is much more efficient than
giving individual numbers, for the former can eliminate
the cost of type checking and unboxing.

Some GL calls can also take @code{gl.math3d} primitive objects
such as @code{vector4f}, @code{point4f} or @code{matrix4f}
(@xref{Vectors and matrices}).   For example, you can pass
@code{point4f} object to @code{gl-vertex}, @code{vector4f} to
@code{gl-normal}, and @code{matrix4f} to @code{gl-mult-matrix}.
They are efficient since calculations on those types are
defined natively in @code{gl.math3d}, and passing it to GL call
doesn't cost unboxing.

@c ----------------------------------------------------------------------
@node Advanced GL features, Using GLUT, GL calls in Scheme, Getting Started
@section Advanced GL features

Although Gauche-gl supports up to OpenGL 2.0, all functionalities
may not be available on the target machine's driver/hardware.
The application needs to check the availability of the extension
and/or GL version before using the features that are only supported
by the extension/version.

Gauche-gl provides a couple of utility procedures to check the
feature sets at runtime.
For example, you can switch behavior depending on OpenGL 1.3 feature
availability:

@example
(if (gl-version>=? "1.3")
  (code-using-features-available-in-OpenGL-1.3-and-later ...)
  (alternative-code ...))
@end example

Or you can check the availability of extensions:

@example
(unless (gl-extension-supported? 'GL_ARB_shader_objects
                                 'GL_ARB_fragment_shader
                                 'GL_ARB_vertex_shader
                                 'GL_ARB_shading_language_100)
   (error "OpenGL Shading Language extensions not available"))
@end example

See @ref{GL feature checking} for the details.

If the client program calls a GL API that are not supported on
the platform, an error is signalled.


@c ----------------------------------------------------------------------
@node Using GLUT, Performance tips, Advanced GL features, Getting Started
@section Using GLUT

In order to make a runnable script, you need to use some
windowing system interface.  GLUT binding provides a simple
way for it.

Here is a complete runnable Scheme script, ported from
Example 1-2 in "OpenGL Programming Guide":

@example
(use gl)
(use gl.glut)

(define (disp)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color '#f32(1.0 1.0 1.0))
  (gl-begin* GL_POLYGON
    (gl-vertex '#f32(0.25 0.25 0.0))
    (gl-vertex '#f32(0.75 0.25 0.0))
    (gl-vertex '#f32(0.75 0.75 0.0))
    (gl-vertex '#f32(0.25 0.75 0.0))
    )
  (gl-flush)
  )

(define (init)
  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-matrix-mode GL_PROJECTION)
  (gl-load-identity)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  )

(define (keyboard key x y)
  (cond
   ((= key 27) (exit 0))
   ))

(define (main args)
  (glut-init args)
  (glut-init-display-mode (logior GLUT_SINGLE GLUT_RGB))
  (glut-init-window-size 250 250)
  (glut-init-window-position 100 100)
  (glut-create-window "hello")
  (init)
  (glut-display-func disp)
  (glut-keyboard-func keyboard)
  (glut-main-loop)
  0)
@end example

The @code{(use gl.glut)} form loads GLUT binding.
The name mapping is the same as GL's: mixed case names to 
hyphenated names.

In order to handle various events, you can pass a closure
to @code{glut-display-func} etc.  In the keyboard and mouse
event callback, all arguments are integers.

There are more examples under the @file{examples/} directory
which uses GLUT.

@c ----------------------------------------------------------------------
@node Performance tips,  , Using GLUT, Getting Started
@section Performance tips

If you want to display millions of polygons in 30 fps, 
Gauche-gl is not for you.   Consider using implementations
that compiles into native code.   The purpose of Gauche-gl
is to provide reasonable performance for interactive development
and experiment.

However, if you know some tips, actually you can go quite far,
especially with recent processors and graphics chips.

@table @emph
@item Avoid alocation within the inner loop.
The functional (non-destructive) operations tend to return 
newly-allocated objects.
Use linear-update (destructive) versions instead,
such as @code{matrix-mul!}, @code{u8vector-add!}, etc,
whenever possible.
Pre-allocating temporary vectors is also effective.

@item Reduce the number of calls within the inner loop.
Vertex arrays are much better than calling @code{gl-vertex}
over and over.   Also consider using display lists if
you're displaying rigid objects.

@item Keep numbers within a uniform vector.
Every time you take a number out of a uniform vector
(or @code{<vector4f>} etc.), Gauche has to wrap the
number by a tag (boxing).  Also when you store a number
into a uniform vector, Gauche has to check the type
of the object, then strip a tag (unboxing).
Those are all overhead you wouldn't have if
you operate directly on uniform vectors (or @code{<vector4f>} etc).

@item Write extensions to accelerate.
If the above strategies are not enough, consider writing
computation-intensive part in C as an extension.
The easier way is to make C routines operate on uniform vectors,
which is essentially a pointer to an array of numbers from C,
and let Scheme handle higher-level data structures.
(It could be viewed like relations between a coprocessor and
a processor; the former does simple, iterative calculations
fast, and the latter handles complicated logic).
@end table

@c ======================================================================
@node OpenGL API, GLUT API, Getting Started, Top
@chapter OpenGL API

In this chapter we list a GL and GLU procedures accessible from
Gauche-gl, with brief descriptions to help programmers
to remind what the functions are.  We don't intend to make
this an OpenGL reference, though; you should look at the OpenGL book
for the details of what each API do.

@menu
* GL data types::               
* GL feature checking::         
* Drawing functions::           
* GL state control::            
* GL states for drawing::       
* Transformation::              
* Display lists::               
* Vertex arrays::               
* Lighting::                    
* Pixels::                      
* Texture mapping::             
* Framebuffers::                
* Selection and feedback::      
* Projection::                  
* Quadrics::                    
* Nurbs::                       
* Polygon tesselation::         
* Programmable shaders::        
@end menu

@c ----------------------------------------------------------------------
@node GL data types, GL feature checking, OpenGL API, OpenGL API
@section GL data types

GL doesn't define many data structures: some scalar primitives (e.g.
@code{GLint}) and arrays of them.

For scalar values, Gauche-gl has natural mappings:
@table @code
@item GLboolean
Scheme booleans.
@item GLbyte, GLubyte, GLshort, GLushort, GLint, GLuint, GLenum, GLbitfield
Scheme exact integers.
@item GLfloat, GLdouble, GLclampf, GLclampd
Scheme real numbers.
@end table


For arrays, Gauche-gl uses uniform (srfi-4) vector whenever possible.
For float arrays, however, Gauche-gl allows more structured types,
such as points or matrices, when they are relevant.  Such types are provided
in @code{gl.math3d} module (see @ref{Vectors and matrices}),
which also provides common arithmetics between those types.
Another exception is an array of GLboolean---it doesn't have corresponding
uniform vector representation.  Gauche-gl defines a new type,
@code{<gl-boolean-vector>}, to represent an array of GLboolean.
See below for operations provided on it.

@table @code
@item GLbyte[]
@code{<s8vector>}
@item GLubyte[]
@code{<u8vector>}
@item GLshort[]
@code{<s16vector>}
@item GLushort[]
@code{<u16vector>}
@item GLint[]
@code{<s32vector>}
@item GLuint[]
@code{<u32vector>}
@item GLfloat[], GLclampf[]
@code{<f32vector>}, @code{<point4f>}, @code{<vector-4f>},
@code{<point4f-array>}, @code{<vector4f-array>},
@code{<matrix4f>}, @code{<quatf>}.
@item GLdouble[], GLclampd[]
@code{<f64vector>}
@item GLboolean[]
@code{<gl-boolean-vector>}
@end table

@subheading GL boolean vectors

@deftp {Class} <gl-boolean-vector>
A class for an array of boolean values.  You can pass its instance
to the GL APIs that expect an array of GLbooleans.  Its internal
representation is bitwise compatible to GLbooean array, so passing
it is quite efficient.

This class inherits @code{<sequence>}, so you can use generic
sequence operations on it.

The external representation of GL boolean vector uses srfi-10
notation, and can be read back.  For example, a GL boolean vector
of length 5 may be written something like this:
@example
#,(gl-boolean-vector #t #f #t #f #t)
@end example
@end deftp

@defun make-gl-boolean-vector size &optional init
Returns a GL boolean vector of @var{size} elements.  Elements are
initialized by either @code{#f} or @code{#t}, according to @var{init}.

@example
(make-gl-boolean-vector 3 #t) @result{} #,(gl-boolean-vector #t #t #t)
@end example
@end defun

@defun gl-boolean-vector bool @dots{}
Returns a GL boolean vector, whose elements are @var{bool} @dots{}.

@example
(gl-boolean-vector #f #t #t) @result{} #,(gl-boolean-vector #f #t #t)
@end example
@end defun

@defun gl-boolean-vector? obj
Returns @code{#t} if @var{obj} is a GL boolean vector, @code{#f} otherwise.
@end defun

@defun gl-boolean-vector-length v
Returns length of a GL boolean vector @var{v}.
You can also use the sequence generic function @code{size-of}.
@end defun

@defun gl-boolean-vector-fill! v bool
Fills a GL boolean vector @var{v} with a boolean value @var{bool}.
@end defun

@defun list->gl-boolean-vector bools
Coerce list of boolean values to a GL boolean vector.

You can also use the @code{coerce-to} generic function to convert
between GL boolean vectors and other sequences.
@end defun

@defun gl-boolean-vector-ref v k &optional fallback
Returns @var{k}-th element of a GL boolean vector @var{v}.
If @var{k} is out of range and @var{fallback} is provided,
it is returned.  If @var{k} is out of range and @var{fallback} is
omitted, an error is signalled.

You can also use generic function @code{ref} to access a
GL boolean vector.
@end defun

@defun gl-boolean-vector-set! v k bool
Sets @var{k}-th element of a GL boolean vector @var{v}
by a boolean value @var{bool}.

You can also use generic function @code{(setter ref)} to modify a
GL boolean vector.
@end defun

@defun gl-boolean-vector-copy v
Returns a copy of a GL boolean vector @var{v}.
@end defun


@c ----------------------------------------------------------------------
@node GL feature checking, Drawing functions, GL data types, OpenGL API
@section GL feature checking

If you want to use a feature that are in OpenGL 1.2 or later, or
in a GL extension, you have to check its availability before
actually calling the API function.  You can use the following
utility procedures.

Note that those functions may return @code{#f} if the connection
to the display subsystem isn't established yet.  Usually you have
to initialize and open an window before checking the features.

@defun gl-extension-available? extension-name @dots{}
Returns @code{#t} if GL extensions listed in @var{extension-name} @dots{}
are all available.  @var{Extension-name} can be a symbol or
a string (e.g. @code{GL_ARB_multisample}).
@end defun

@defun gl-version<? version
@defunx gl-version<=? version
@defunx gl-version>? version
@defunx gl-version>=? version
@defunx gl-version=? version
Returns @code{#t} if the runtime OpenGL version is less than,
less thanor equal to, greater than, greater than or equal to,
and equal to, the given @var{version}, respectively.

Give @var{version} in a string, e.g. @code{"1.3"}.
@end defun

@c ----------------------------------------------------------------------
@node Drawing functions, GL state control, GL feature checking, OpenGL API
@section Drawing functions

@defmac gl-begin* mode gl-commands @dots{}
@vindex GL_POINTS
@vindex GL_LINES
@vindex GL_LINE_STRIP
@vindex GL_LINE_LOOP
@vindex GL_TRIANGLES
@vindex GL_TRIANGLE_STRIP
@vindex GL_TRIANGLE_FAN
@vindex GL_QUADS
@vindex GL_QUAD_STRIP
@vindex GL_POLYGON

Executes @var{gl-commands} between @code{(gl-begin @var{mode})} and
@code{(gl-end)}.  @var{Mode} can be one of the following constants.

@table @code
@item GL_POINTS
Individual points.
@item GL_LINES
Pairs of vertices interpreted as individual line segments.
@item GL_LINE_STRIP
Series of connected line segments.
@item GL_LINE_LOOP
Same as above, with a segment added between last and first vertices.
@item GL_TRIANGLES
Triples of vertices interpreted as triangles.
@item GL_TRIANGLE_STRIP
Linked trip of triangles.
@item GL_TRIANGLE_FAN
Linked fan of triangles.
@item GL_QUADS
Quadruples of vertices interpreted as four-sided polygons.
@item GL_QUAD_STRIP
Linked strip of quadrilaterals.
@item GL_POLYGON
Boundary of a simple, convex polygon.
@end table

@end defmac

@defun gl-begin mode
@defunx gl-end
Corresponds to @code{glBegin} and @code{glEnd}.
Use of @code{gl-begin*} macro is recommended, though.
@end defun

@defun gl-flush
Flush the GL command buffer.
@end defun

@defun gl-finish
Make sure all previously issued GL commands are completed.
@end defun

@defun gl-rect point1 point2
@defunx gl-rect x1 y1 x2 y2
Draws a rectangle.  In the first form,
@var{point1} and @var{point2} can be either
@code{<point4f>}, or f32, f64, s32, or s16vector of
length 2.   Types of both args should match.  
In the second form, all args should be a real numbers (@code{glRectd} is used).
@end defun

@defun gl-vertex point
@defunx gl-vertex x y &optional z w
Specify vertices.  In the first form, @var{point} can be
either @code{<point4f>}, or f32, f64, s32 or s16vector
of length 2, 3 or 4.
In the second form, all args should be a real numbers.
@end defun

@defun gl-normal vector
@defunx gl-normal x y z
Sets vertex normal vector.  In the first form, @var{vector} can be
either @code{<vector4f>} (the fourth element is ignored),
or f32, f64, s32 ro s16vector of length 3.
In the second form, all args should be a real numbers.
@end defun

@defun gl-color color
@defunx gl-color r g b &optional a
Sets the current color.  In the first form, @var{color} can be
either f32, f64, u8, u16, u32, s8, s16, or s32vector of length 3 or 4.
In the second form, all args should be a real numbers.
@end defun

@defun gl-tex-coord coord
@defunx gl-tex-coord u v &optional s t
Sets the current texture coordinates.  In the first form,
@var{coord} can be either f32, f64, s32 or s16vector of length
1, 2, 3, or 4.  In the second form, all args should be a real numbers.
@end defun

@defun gl-raster-pos pos
@defunx gl-raster-pos x y &optional z w
Sets the current raster position.  In the first form,
@var{pos} can be eitehr f32, f64, s32 or s16vector.  In the
second form, all args should be a real numbers.
@end defun

@c ----------------------------------------------------------------------
@node GL state control, GL states for drawing, Drawing functions, OpenGL API
@section GL state control

@subsubheading Capabilities

@defun gl-enable cap
@defunx gl-disable cap
Turns on and off a capability @var{cap}.  Check out OpenGL reference
for the list of capabilities.
@end defun

@defun gl-is-enabled cap
Returns @code{#t} of @code{#f} depending on @var{cap} is enabled or not.
@end defun

@defun gl-enable-client-state array
@defunx gl-disable-client-state array
Enable/disable a client-side array (e.g. vertex array) specified by
@var{array}.   @var{Array} can be one of the following constants.

@table @code
@item GL_VERTEX_ARRAY
@item GL_COLOR_ARRAY
@item GL_INDEX_ARRAY
@item GL_NORMAL_ARRAY
@item GL_TEXTURE_COORD_ARRAY
@item GL_EDGE_FLAG_ARRAY
@end table

@end defun

@subsubheading State values

Gauche has two variations for each type of OpenGL @code{glGetTYPE} APIs;
nondestructive version and destructive versions.  Nondestructive versions
such as @code{gl-get-boolean} allocates and returns the vector of
appropriate type for the state.  For destructive versions such as
@code{gl-get-boolean!}, you need to pass a vector to be filled in.

The destructive version is non-allocating operation, so it is suitable
if you call it within the drawing loop.

If the state has a scalar value, the non-destructive version of
query function returns a scalar value, but you need to pass a 
(uniform) vector of length 1 for the destructive version.

@defun gl-state-vector-size state
[Gauche specific]
Returns the required size of the vector to retrieve GL state @var{state}.
It is useful to prepare the vector to pass to the destructive version
of @code{glGetTYPE} API.
@end defun

@defun gl-get-boolean state
@defunx gl-get-boolean! gl-boolean-vector state
Get (a) boolean state value(s).
@end defun

@defun gl-get-integer state
@defunx gl-get-integer! s32vector state
Get (an) integer state value(s).
@end defun

@defun gl-get-float state
@defunx gl-get-float! f32vector state
Get (a) single-precision floating-point state value(s).
@end defun

@defun gl-get-double state
@defunx gl-get-double! f64vector state
Get (a) double-precision floating-point state value(s).
@end defun

@subsubheading Push/pop attributes

@defun gl-push-attrib mask
@defunx gl-pop-attrib
Push/pop attributes indicated by @var{mask}.
Valid @var{mask} can be @code{logior} of the following bits
(GLL_ALL_ATTRIB_BITS is @code{logior} of all the bits).

@table @code
@item GL_ACCUM_BUFFER_BIT
@item GL_COLOR_BUFFER_BIT
@item GL_CURRENT_BIT
@item GL_DEPTH_BUFFER_BIT
@item GL_ENABLE_BIT
@item GL_EVAL_BIT
@item GL_FOG_BIT
@item GL_HINT_BIT
@item GL_LIGHTING_BIT
@item GL_LINE_BIT
@item GL_LIST_BIT
@item GL_PIXEL_MODE_BIT
@item GL_POINT_BIT
@item GL_POLYGON_BIT
@item GL_POLYGON_STIPPLE_BIT
@item GL_SCISSOR_BIT
@item GL_STENCIL_BUFFER_BIT
@item GL_TEXTURE_BIT
@item GL_TRANSFORM_BIT
@item GL_VIEWPORT_BIT
@item GL_ALL_ATTRIB_BITS
All of the above.
@end table
@end defun

@defun gl-push-client-attrib mask
@defunx gl-pop-client-attrib 
Push/pop client attributes.  Valid @var{mask} can be
@code{logior} of the following

@table @code
@item GL_CLIENT_PIXEL_STORE_BIT
@item GL_CLIENT_VERTEX_ARRAY_BIT
@item GL_ALL_CLIENT_ATTRIB_BITS
All of the above.
@end table
@end defun

@subsubheading Other queries

@defun gl-get-error
Returns the value of the error flag.  Returned an integer value.
Check out the OpenGL documentation for the possible error values.

This function resets the error flag to @code{GL_NO_ERROR}.
@end defun

@defun glu-error-string error-code
Returns a descriptive string for @var{error-code} returned by
@code{gl-get-error}.
@end defun

@defun gl-get-string name
Returns informative string about @var{name} of the GL library.
@var{Name} can be one of the following.

@table @code
@item GL_VENDOR
@item GL_RENDERER
@item GL_VERSION
@item GL_EXTENSIONS
@end table

To check a specific version or extension, you can also use
the utility procedure @code{gl-version>?} etc.  See
@ref{GL feature checking}.
@end defun

@defun glu-get-string name
Returns informative string about @var{name} of the GLU library.
@var{Name} can be one of the following.

@table @code
@item GLU_VERSION
@item GLU_EXTENSIONS
@end table
@end defun

@subsubheading Hints

@defun gl-hint target hint
Controls quality of @var{target} by @var{hint}.
@var{Target} can be one of the following:

@table @code
@item GL_POINT_SMOOTH_HINT
@item GL_LINE_SMOOTH_HINT
@item GL_POLYGON_SMOOTH_HINT
@item GL_FOG_HINT
@item GL_PERSPECTIVE_CORRECTION_HINT
@end table

And @var{hint} can be one of the following:
@table @code
@item GL_FASTEST
@item GL_NICEST
@item GL_DONT_CARE
@end table
@end defun


@c ----------------------------------------------------------------------
@node GL states for drawing, Transformation, GL state control, OpenGL API
@section GL states for drawing

@defun gl-point-size size
Sets the width in pixels for rendered points.
The possible range of @var{size} on the running GL implementation
can be obtained by passing either @code{GL_ALIASED_POINT_SIZE_RANGE} or
@code{GL_SMOOTH_POINT_SIZE_RANGE} to @code{gl-get-float}.
@end defun

@defun gl-line-width width
Sets the width in pixels for rendered lines.
The possible range of @var{width} on the running GL implementation
can be obtained by passing either @code{GL_ALIASED_LINE_WIDTH_RANGE} or
@code{GL_SMOOTH_LINE_WIDTH_RANGE} to @code{gl-get-float}.
@end defun

@defun gl-line-stipple factor pat
Sets the current stippling pattern for lines.
@code{pat} must be an exact integer, and its lower 16 bits are used
to specify the stipple pattern.  @var{Factor} is an integer factor
to specify how many pixels corresponds to one bit in @var{pat}.

You have to enable @var{GL_LINE_STIPPLE} to use face culling.
@end defun

@defun gl-polygon-mode face mode
Specifies the drawing mode for a polygon's front and back faces.
@var{Face} can be one of the followings:
@table @code
@item GL_FRONT_AND_BACK
@item GL_FRONT
@item GL_BACK
@end table

@var{Mode} can be one of the followings:
@table @code
@item GL_POINT
@item GL_LINE
@item GL_FILL
@end table
@end defun

@defun gl-front-face mode
Controls how OpenGL determine front face of a polygon
@var{Mode} can be one of the followings:
@table @code
@item GL_CCW
Front face is where ordered vertices appear in a counterclockwise orientation
(default).
@item GL_CW
Front face is where ordered vertices appear in a clockwise orientation.
@end table
@end defun

@defun gl-cull-face mode
Indicates which face of polygons should be culled.
@var{Mode} can be one of the followings:
@table @code
@item GL_FRONT
@item GL_BACK
@item GL_FRONT_AND_BACK
@end table

You have to enable @var{GL_CULL_FACE} to use face culling.
@end defun

@defun gl-polygon-stipple mask
Defines the current stipple pattern for filled polygons.
@var{Mask} has to be a u8vector of length 128, specifying a 32x32 
bitmap pattern.
You have to enable @var{GL_POLYGON_STIPPLE} to use this feature.
@end defun


@defun gl-edge-flag flag
Sets the edge flag(s) of vertices.   When @var{flag} is
a GL boolean vector, @code{glEdgeFlagv} is called.
Otherwise @var{flag} is used as a single boolean value
for @code{glEdgeFlag}.
@end defun

@defun gl-blend-func sfactor dfactor
Controls how color values in the fragment being processed (the source)
are combined with the ones in the framebuffer (the destination).

Possible values for the @var{sfactor} and @var{dfactor} arguments
are as follows.
@table @code
@item GL_ZERO
@item GL_ONE
@item GL_DST_COLOR
@item GL_SRC_COLOR
@item GL_ONE_MINUS_DST_COLOR
@item GL_ONE_MINUS_SRC_COLOR
@item GL_SRC_ALPHA
@item GL_ONE_MINUS_SRC_ALPHA
@item GL_DST_ALPHA
@item GL_ONE_MINUS_DST_ALPHA
@item GL_SRC_ALPHA_SATURATE
@item GL_CONSTANT_COLOR
@item GL_ONE_MINUS_CONSTANT_COLOR
@item GL_CONSTANT_ALPHA
@item GL_ONE_MINUS_CONSTANT_ALPHA
@end table
@end defun

@defun gl-blend-equation mode
[GL_ARB_imaging]
By default, the source and destination colors are added after
processed as specified by @var{gl-blend-func}.  With this extension API
you can change the function.  @var{Mode} can be one of the
following values:
@table @code
@item GL_FUNC_ADD
@item GL_FUNC_SUBTRACT
@item GL_FUNC_REVERSE_SUBTRACT
@item GL_MIN
@item GL_MAX
@end table
@end defun

@defun gl-blend-color red green blue alpha
[GL_ARB_imaging]
Sets the constant color used in the blending function.
@end defun

@defun gl-polygon-offset factor units
[GL1.1]
Offset the depth value of each fragment.  Useful to avoid
artifacts when you draw polygon edges over its surfaces, 
for example.
@end defun

@defun gl-clip-plane plane equation
Defines a clipping plane.  @var{Plane} specifies which clipping
plane you're defining.  Use @code{GL_MAX_CLIP_PLANES} to
@code{gl-get-integer} to obtain the number of clipping planes
you can use.  You have to enable the specific clipping plane
(e.g. @code{(gl-enable GL_CLIP_PLANE0)}) to use the clipping plane.

@var{Equation} must be an f64vector of size 4, specifying four
coefficients of the plane equation, @code{Ax + By + Cz + D = 0}.
@end defun

@defun gl-get-clip-plane plane
Returns the four coefficients of the equation of clipping plane
@var{plane}, in f64vector.
@end defun

@defun gl-fog pname param
Sets the parameters and function for the fog effect.
Possible values for @var{pname} and accepted @var{param} for each
@var{pname} are shown below.

@table @code
@item GL_FOG_MODE
Either @code{GL_EXP}, @code{GL_EXP2}, @code{GL_LINEAR} to select
the fog factors.
@item GL_FOG_DENSITY
@item GL_FOG_START
@item GL_FO_END
A real number to specify those parametes.
@item GL_FOG_COLOR
An f32vector of size 4 to specify the color.
@end table
@end defun

@c ----------------------------------------------------------------------
@node Transformation, Display lists, GL states for drawing, OpenGL API
@section Transformation

@defun gl-matrix-mode mode
Speficies whether the modelview, projection, or texture matrix
will be modified.   @var{Mode} can be one of the followings:

@table @code
@item GL_MODELVIEW
@item GL_PROJECTION
@item GL_TEXTURE
@end table
@end defun

@defun gl-load-identity
Loads an identity matrix to the current modifiable matrix.
@end defun

@defun gl-load-matrix mat
Loads the matrix @var{mat} to the current modifiable matrix.
@var{Mat} can be a @code{<matrix4f>} instance, or
f32 or f64vector of length 16.
@end defun

@defun gl-mult-matrix mat
Multiplies the matrix @var{mat} to the current modifiable matrix.
@var{Mat} can be a @code{<matrix4f>} instance, or
f32 or f64vector of length 16.
@end defun

@defun gl-translate x y z
Multiplies the current matrix by a matrix taht translates
an object by (@var{x}, @var{y}, @var{z}).
Internally, @code{glTranslated} is called.
@end defun

@defun gl-rotate angle x y z
Multiplies the current matrix by a matrix that rotates
an object in a counterclockwise direction about the ray
from the origin through the point (@var{x}, @var{y}, @var{z})
by @var{angle} degrees.
Internally, @code{glRotated} is called.
@end defun

@defun gl-scale x y z
Multiplies the current matrix by a matrix that scales
an object by (@var{x}, @var{y}, @var{z}).
Internally, @code{glScaled} is called.
@end defun

@defun glu-look-at eyex eyey eyez ctrx ctry ctrz upx upy upz
Defines a viewing matrix and multiplies it to the right of
the current matrix.
@end defun

@defun gl-frustum left right bottom top nearv farv
Creates a matrix for a perspective-view frustum and
multiplies the current matrix by it.
@end defun

@defun glu-perspective fovy aspect znear zfar
Creates a matrix for a symmetrix perspective-view frustum and
multiplies the current matrix by it.
@end defun

@defun gl-ortho left right bottom top nearv farv
Creates a matrix for an orthographic parallel viewing volume nand
multiplies the current matrix by it.
@end defun

@defun glu-ortho-2d left right bottom top
Convenience procedure for 2D drawing; it is the same as @code{gl-ortho}
except nearv and farv are fixed (along Z axis) to -1.0 and 1.0, respectively.
@end defun

@defun gl-viewport x y width height
Defines a pixel rectangle in the window into which the final image
is mapped.
@end defun

@defun gl-push-matrix
@defunx gl-pop-matrix
Pushes/pops the current matrix.
@end defun

@defmac gl-push-matrix* expr @dots{}
A convenience macro.  Pushes the current matrix, 
executes @var{expr}s, then pop the current matrix.
@end defmac


@c ----------------------------------------------------------------------
@node Display lists, Vertex arrays, Transformation, OpenGL API
@section Display lists

@defun gl-gen-lists range
Allocates @var{range} number of contiguous display list indices.
Returns an integer which is the smallest display list index you
can use.
@end defun

@defun gl-new-list list-no mode
Starts a display list construction.   @var{Mode} may be
one of the constants @code{GL_COMPILE} or @code{GL_COMPILE_AND_EXECUTE}.
@end defun

@defun gl-end-list
Ends a display list construction.
@end defun

@defun gl-call-list list-no
Calls a display list.
@end defun

@defun gl-is-list list-no
Returns @code{#t} if @var{list-no} is an already used display list number,
@code{#f} otherwise.
@end defun

@defun gl-delete-lists list-no-start range
Deletes @var{range} display list, beginning from @var{list-no-start}.
@end defun

@defun gl-list-base base
Specifies the offset that's added to the display list indices in
@code{gl-call-list}.
@end defun

@defun gl-call-lists size type lists
@defunx gl-call-lists size lists
@defunx gl-call-lists lists
Executes @var{size} display list, whose indices are contained in @var{lists}.
You can pass a u8, s8, u16, s16, u32, s32 or f32vector, or a string,
as @var{lists}.  If it is a string, each byte consists of the string
is interpreted as an unsigned integer specifying a display list.
It is useful for the technique to display character strings by
creating display lists for each ASCII characters.  But be aware that
it doesn't work for multibyte characters.

Usually you can use the simplest form (the third form) and Gauche-gl
infers the @var{size} and @var{type} from the passed @var{lists}.
You can explicitly specify @var{size} if you want to use just a
beginning portion of @var{lists}.   An error is signalled if you
specify @var{size} that is larger than the size of @var{lists}.

Specifying @var{type} is useful only if @var{lists} is a u8vector,
and you want to use one of three special types allowed to @code{glCallLists},
namely @code{GL_2_BYTES}, @code{GL_3_BYTES}, and @code{GL_4_BYTES}.
@end defun

@c ----------------------------------------------------------------------
@node Vertex arrays, Lighting, Display lists, OpenGL API
@section Vertex arrays

Scheme version of APIs doesn't have @var{GLenum type} argument
in C API, since Gauche-gl can figure out the type by passed 
vectors.

Scheme API of @code{gl-*-array} has @var{offset} optional argument,
by which you can pass the GL the values beginning from the @var{offset}-th
element of the passed uniform vector.   This isn't in GL C API, 
since you can just offset the pointer in C.

NOTE: it is caller's responsibility to guarantee the passed vector
has enough length.  GL doesn't have an interface to specify the boundary,
so Gauche can't detect an invalid length vector.


@defun gl-vertex-pointer size vec &optional stride offset
Sets the vertex array.  @var{Size} specifies the number of 
scalar values per vertex (2, 3, or 4), and @var{vec} provides
the actual value in either f32, f64, s32 or s16vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-normal-pointer vec &optional stride offset
Sets the normal array.  @var{Vec} should be either
a f32, f64, s32 or s16vector, where each consecutive triplet
specifies a normal vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-color-pointer size vec &optional stride offset
Sets the color array.   @var{Size} specifies the number of
scalar values per color (3 or 4), and @var{vec} provides
the actual values in either f32, f64, u32, u16, u8, s32, s16, or s8vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-index-pointer vec &optional stride offset
Sets the index array.   @var{Vec} can be either s32, s16, u8, f32, or
f64vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-tex-coord-pointer size vec &optional stride offset
Sets the texture coordinate array.  @var{Size} specifies the
number of scalar values per texture coordinate (1, 2, 3 or 4),
and @var{vec} provides the actual values in either f32, f64, s32 or
s16vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-edge-flag-pointer vec &optional stride offset
Sets the edge flag array.  @var{Vec} must be a GL boolean vector.
@code{Stride} and @var{offset} can be used to tell GL to 
access @var{vec} sparsely.
@end defun

@defun gl-array-element ith
Dereference @var{ith} vertex information of the currently enabled arrays.
@end defun

@defun gl-draw-elements mode indices
Issues geometric primitive calls consists of the vertex information
of the currently enabled arrays, each of which is specified
by @var{indices}, which should be either a u8, u16 or u32vector.

@var{Mode} is the same as of @code{gl-begin}.
@end defun

@defun gl-draw-range-elements mode start end indices
[GL1.2] Like @code{gl-draw-elements}, but limits the range of indices
between @var{start} and @var{end}, inclusive.  GL driver may take
advantage of the information for better performance.
@end defun

@defun gl-draw-arrays mode first count
This is more straightforward.  Starting from @var{first} index,
@var{count} vertices is wrtten in the drawing mode @var{mode}
(same as of @code{gl-begin}), taken from the current enabled arrays.
@end defun

@defun gl-interleaved-arrays format vec &optional stride offset
@var{Vec} must be a f32vector.  It contains various information
(e.g. vertex position, color and texture coordinate) interleaved,
in the way specified by @var{format}.

In Scheme API, we only allow uniform vector as @var{vec}, so
you can't use the format that mixes float and integer, such as
@code{GL_C4UB_V2F}.
@end defun

@c ----------------------------------------------------------------------
@node Lighting, Pixels, Vertex arrays, OpenGL API
@section Lighting

@defun gl-shade-model mode
Sets the shading model, either @code{GL_SMOOTH} or @code{GL_FLAT}.
@end defun

@defun gl-light light pname param
Creates a light specified by @var{light}, which is
one of  @code{GL_LIGHT0}, @dots{}, @code{GL_LIGHT7},
and sets a characteristics named by @var{pname} with the value @var{param}.

Possible values as @var{pname} and acceptable types of @var{param} are
as follows.
@table @asis
@item @code{GL_AMBIENT}, @code{GL_DIFFUSE}, @code{GL_SPECULAR}, @code{GL_POSITION}
Accepts an f32 or s32vector of size 4.
@item @code{GL_SPOT_DIRECTION}
Accepts an f32 or s32vector of size 3.
@item @code{GL_SPOT_EXPONENT}, @code{GL_SPOT_CUTOFF}, @code{GL_CONSTNAT_ATTENUATION}, @code{GL_LINEAR_ATTENUATION}, @code{GL_QUADRATIC_ATTENUATION}
Accepts a real number (@code{glLightf} is used).
@end table
@end defun

@defun gl-get-light light pname
Returns the value of the property @var{pname} of the light @var{light}.
Returned value can be f32vector or a real number.
@end defun

@defun gl-light-model pname param
Sets the value of the property @var{pname} of the lighting model.
Possible @var{pname} and its allowed @var{param} is as follows.
@table @asis
@item @code{GL_LIGHT_MODEL_AMBIENT}
Accepts f32 or s32vector of size 4.
@item @code{GL_LIGHT_MODEL_LOCAL_VIEWER}, @code{GL_LIGHT_MODEL_TWO_SIDE}
Accepts any Scheme value, which is interpreted as a boolean value.
(That is, you have to pass @code{#f} to turn off these properties,
and any other value to turn on.
@item @code{GL_LIGHT_MODEL_COLOR_CONTROL}
Accepts an enum value either @code{GL_SINGLE_COLOR} or
@code{GL_SEPARATE_SPECULAR_COLOR}.
@end table
@end defun

@defun gl-material face pname param
Sets the current material property.  @var{Face} may be either
@code{GL_FRONT}, @code{GL_BACK}, or @code{GL_FRONT_AND_BACK}.
Possible values of @var{pname} and acceptable @var{param} types are
as follows.
@table @asis
@item @code{GL_AMBIENT}, @code{GL_DIFFUSE}, @code{GL_AMBIENT_AND_DIFFUSE}, @code{GL_SPECULAR}, @code{GL_EMISSION}
Accepts f32 or s32vector of size 4.
@item @code{GL_SHININESS}
Accepts a single real number (@code{glMaterialf} is called).
@item @code{GL_COLOR_INDEXES}
Accepts f32 or s32vector of size 3.
@end table
@end defun

@defun gl-get-material face pname
Returns the current material property of @var{face} and @var{pname}.
The type of returned value may be f32vector, s32vector (only for 
@code{GL_COLOR_INDEXES}), or a real number.
@end defun

@defun gl-color-material face mode
Makes the material property @var{mode} (e.g. @code{GL_AMBIENT} etc.)
of the face @var{face} follow the current color set by @code{gl-color}.
@end defun

@c ----------------------------------------------------------------------
@node Pixels, Texture mapping, Lighting, OpenGL API
@section Pixels, bitmaps and images

@subheading Pixel operations

@defun gl-bitmap width height xbo ybo xbi ybi bitmap
Draws a bitmap.  @var{Width} and @var{height} gives the dimension
of the bitmap.  @var{Xbo}, @var{ybo}, @var{xbi}, and @var{ybi}
specifies the origin and increment of the current raster position.
@var{Bitmap} is the actual bitmap data, packed in a u8vector.
@end defun

@defun gl-read-pixels x y width height format type
Reads pixel data from the framebuffer.  Returns the pixel data
in a uniform vector of the type determined by @var{format} and
@var{type} (check out OpenGL doc to find out the actual data format).
@end defun

@defun gl-draw-pixels width height format type pixels
Draws a pixel data @var{pixels} at the current raster position.
@var{Pixels} must be a uniform vector compatible to the specified
@var{format} and @var{type} values.
@end defun

@defun gl-copy-pixels x y width height buffer
Copies pixel data in a rectangle area of the framebuffer,
specified by lower-left corner (@var{x}, @var{y}) and dimensions
(@var{width}, @var{height}).   @var{Buffer} specifies which buffer
is used, and should be one of @code{GL_COLOR}, @code{GL_STENCIL}
or @code{GL_DEPTH}.
@end defun

@defun gl-pixel-store pname param
Sets the pixel stroage models.  Check out the OpenGL doc for
the possible @var{pname} and @var{param} values.
@end defun

@defun gl-pixel-transfer pname param
Sets the pixel transfer modes.  Check out the OpenGL doc for
the possible @var{pname} and @var{param} values.
@end defun

@defun gl-pixel-map map values
Sets the pixel map table @var{map} with @var{values},
which must be either u16, u32 or f32vecotor.
Check out the OpenGL doc for the possible @var{map} values.
@end defun

@defun gl-pixel-zoom xfactor yfactor
Sets the magnification/reduction factors for pixel-write operations.
@end defun

@defun gl-get-pixel-map map &optional type
Returns the current pixel map table as an uniform vector specified
by @var{type}, which must be either a class @code{<u32vector>} (default),
@code{<u16vector>}, or @code{<f32vector>}.
@end defun

@defun gl-get-pixel-map! map values
Like @code{gl-get-pixel-map}, but instead of allocating a new vector,
it stores the result to a uniform vector passed to @var{values}.
It is a caller's responsibility to ensure @var{values} has enough size.
@end defun

@subheading Color tables

@defun gl-color-table target internal-format width format type data
[GL_ARB_imaging] 
Specifies one of the color table @var{target}.
@var{Data} should be a uniform vector compatible to the
@var{format} and @var{type} parameters.
@end defun

@defun gl-color-table-parameter target pname param
[GL_ARB_imaging]
Sets the color table parameter @var{pname}
(either @code{GL_COLOR_TABLE_SCALE} or @code{GL_COLOR_TABLE_BIAS}),
of the color table @var{target}.  @var{Param} must be 
an f32 or s32vector of size 4.
@end defun

@defun gl-copy-color-table target internal-format x y width
[GL_ARB_imaging]
Creates a color table @var{target} using framebuffer data.  
The pixels are
read from the current buffer for read (specified by @code{glReadBuffer}).
@end defun

@defun gl-color-sub-table target start count format type data
[GL_ARB_imaging]
Replaces a part of color table @var{target}, starting @var{start}
and @var{count} entries.  Values are given in @var{data} as a
uniform vector compatible to the @var{format} and @var{type} arguments.
@end defun

@defun gl-copy-color-sub-table target start x y width
[GL_ARB_imaging] Replaces a part of color table entries using framebuffer data.
@end defun

@defun gl-get-color-table! target format type data
[GL_ARB_imaging]
Reads the color table @var{target} and store it in @var{data},
in the format specified by @var{format} and @var{type}.
@var{Data} must be a uniform vector compatible to the
@var{format} and @var{type} arguments.  The caller must ensure
that @var{data} has enough size to contain the result.
@end defun

@subheading Convolutions

@defun gl-convolution-filter-2d target internal-format width height format type data
[GL_ARB_imaging]
Defines a 2D convolution filter.  @var{Target} must be GL_CONVOLUTION_2D.
@code{Data} must be a uniform vector
compatible to the @var{format} and @var{type} arguments, and must have
enough size.
@end defun

@defun gl-copy-convolution-filter-2d target internal-format x y width height
[GL_ARB_imaging]
Defines a 2D convolution filter, 
taking the convolution filter data from the current color buffer to read.
@end defun

@defun gl-separable-filetr-2d target internal-format width height format type row column
[GL_ARB_imaging]
Defines a 2D convolution filter by a product of a 1D row vector and
1D column vector.  @var{Target} must be GL_SEPARABLE_2D.
Both @var{row} and @var{column} must be a uniform
vector, compatible with the @var{format} and @var{type} arguments,
and must have enough size.
@end defun

@defun gl-convolution-filter-1d target internal-format width format type data
[GL_ARB_imaging]
Defines 1D convolution filter.  @var{Target} must be GL_CONVOLUTION_1D.
@code{Data} must be a uniform vector
compatible to the @var{format} and @var{type} arguments, and must have
enough size.
@end defun

@defun gl-copy-convolution-filter-1d target internal-format x y width
[GL_ARB_imaging]
Defines 1D convolution filter, taking the convolution filter data
from the current color buffer to read.
@end defun

@defun gl-convolution-parameter target pname param
[GL_ARB_imaging]
Sets a parameter for a convolution filter @var{target}, which can 
be either @code{GL_CONVOLUTION_2D}, @code{GL_SEPARABLE_2D},
or @code{GL_CONVOLUTION_1D}.  Possible values of @var{pname} and 
their acceptable @var{param} are as follows.
@table @asis
@item @code{GL_CONVOLUTION_BORDER_MODE}
Either one of the constants: @code{GL_REDUCE}, @code{GL_CONSTNAT_BORDER},
@code{GL_REPLICATE_BORDER}
@item @code{GL_CONVOLUTION_FILTER_SCALE}, @code{GL_CONVOLUTION_FILTER_BIAS}
An s32 or f32vector of size 4, specifying color values.
@end table
@end defun


@subheading Histogram

@defun gl-histogram target width internal-format sink
[GL_ARB_imaging]
Specifies the way the histogram data is stored.
@var{Target} must be either @code{GL_HISTOGRAM} or @code{GL_PROXY_HISTOGRAM}.
@var{Width} is the number of entires of the histogram, and has to be
a power of 2.
@var{Sink} is a boolean value to indicate whether pixels should be
discarded or sent down further to the pipeline.
@end defun

@defun gl-reset-histogram target
[GL_ARB_imaging]
Resets the histogram counters.  @var{Target} must be @code{GL_HISTOGRAM}.
@end defun

@defun gl-get-histogram target reset format type
[GL_ARB_imaging]
Returns histogram data in a uniform vector, whose type and size
are determined by @var{format} and @var{type}.
A boolean value @var{reset} specifies whether the histogram should
be reset or not.
@end defun

@defun gl-get-histogram-parameter target pname
[GL_ARB_imaging]
Returns the parameter value of the histogram.
@var{Pname} can be either one of @code{GL_HISTOGRAM_WIDTH},
@code{GL_HISTOGRAM_FORMAT}, @code{GL_HISTOGRAM_RED_SIZE},
@code{GL_HISTOGRAM_GREEN_SIZE}, @code{GL_HISTOGRAM_BLUE_SIZE},
@code{GL_HISTOGRAM_ALPHA_SIZE}, @code{GL_HISTOGRAM_LUMINANCE_SIZE},
or @code{GL_HISTOGRAM_SINK}.  The returned value is an integer,
except the case of @code{GL_HISTOGRAM_SINK}, which returns a boolean value.
@end defun


@subheading Minmax

@defun gl-minmax target internal-format sink
[GL_ARB_imaging]
Computes the minimum and maximum pixel values for an image.
@var{Target} must be @code{GL_MINMAX}.
@var{Sink} is a boolean value to indicate whether pixels should be
discarded or sent down further to the pipeline.
@end defun

@defun gl-get-minmax target reset format type
[GL_ARB_imaging]
Returns the results of the minmax operation in a uniform vector,
whose type and size are determined by the @var{format} and
@var{type} arguments.
A boolean value @var{reset} specifies whether the histogram should
be reset or not.
@end defun

@defun gl-reset-minmax target
[GL_ARB_imaging]
Resets the minmax counter.
@end defun

@defun gl-get-minmax-parameter target pname
[GL_ARB_imaging]
Returns the parameter value of the histogram.
@var{Pname} can be either @code{GL_MINMAX_SINK} (returns
a boolean value) or @code{GL_MINMAX_FORMAT} (returns an integer).
@end defun

@c ----------------------------------------------------------------------
@node Texture mapping, Framebuffers, Pixels, OpenGL API
@section Texture mapping

@subheading Defining textures

@defun gl-tex-image-1d target level internalformat width border format type texels
@defunx gl-tex-image-2d target level internalformat width height border format type texels
@defunx gl-tex-image-3d target level internalformat width height depth border format type texels
Defines an 1D, 2D or 3D texture.   3D texture is available only
if the GL version is 1.2 or later.
The @var{target} parameter can be @code{GL_TEXTURE_1D} or 
@code{GL_PROXY_TEXTURE_1D} for @code{gl-tex-image-1d}, etc.
The @var{level} parameter can be used for multiresolution textures; if
this is a single resolution texture, pass 0.

@var{Width}, @var{height}, and @var{depth} specify 
the dimensions of the texture.
@var{Border} can be 0 or 1, specifying the border.

The actual texture data is passed to the @var{texels} argument in
a uniform vector, which should be compatible with the @var{format}
and @var{type} parameters and match the size calculated by @var{width},
@var{height} and @var{depth} (and possibly the pixel store setting).
@end defun

@defun gl-copy-tex-image-1d target level internal-format x y width border
@defunx gl-copy-tex-image-2d target level internal-format x y width height border
Cerates a 1D or 2D texture from the framebuffer data.
@end defun

@defun gl-tex-sub-image-1d target level xoffset width format type texels
@defunx gl-tex-sub-image-2d target level xoffset yoffset width height format type texels
@defunx gl-tex-sub-image-3d target level xoffset yoffset zoffset width height depth format type texels
Replaces a  part of the current 1D, 2D or 3D texture image by @var{texels}.
3D texture is available only
if the GL version is 1.2 or later.
@end defun

@defun gl-copy-tex-sub-image-1d target level xoffset x y width
@defunx gl-copy-tex-sub-image-2d target level xoffset yoffset x y width height
@defunx gl-copy-tex-sub-image-3d target level xoffset yoffset zoffset x y width height
Replaces a part of the current 1D, 2D or 3D texture image by
the data from the framebuffer.   3D texture is available only
if the GL version is 1.2 or later.
@end defun

@subheading Texture parameters

@defun gl-tex-parameter target pname param
Sets parameters for the current texture.
@var{Target} can be either @var{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D} or
@var{GL_TEXTURE_3D}.  Possible values for @var{pname}, and accepted
type of @var{param} for each @var{pname}, are shown below.

@table @code
@item GL_TEXTURE_WRAP_S
@item GL_TEXTURE_WRAP_T
@item GL_TEXTURE_WRAP_R
@item GL_TEXTURE_BASE_LEVEL
@item GL_TEXTURE_MAX_LEVEL
@item GL_TEXTURE_MAG_FILTER
@item GL_TEXTURE_MIN_FILTER
@var{Param} must be an integer.
@item GL_TEXTURE_PRIORITY
@item GL_TEXTURE_MIN_LOD
@item GL_TEXTURE_MAX_LOD
@var{Param} must be a real number.
@item GL_TEXTURE_BORDER_COLOR
@var{Param} must be an f32vector of size 4, representing a color.
@end table
@end defun

@defun gl-get-tex-parameter target pname
Obtains the parameter of the current texture, set by @code{gl-tex-parameter}.
@end defun

@defun gl-get-tex-level-parameter target level pname
Obtains the parameter of the level @var{level} 
of the current texture specified by @var{target},
which can be either @code{GL_TEXTURE_1D}, @code{GL_TEXTURE_2D}, 
@code{GL_TEXTURE_3D}, @code{GL_PROXY_TEXTURE_1D}, 
@code{GL_PROXY_TEXTURE_2D}, or @code{GL_PROXY_TEXTURE_3D}.

Possible values for @var{pname} is either one of the
following constants: @code{GL_TEXTURE_WIDTH}, @code{GL_TEXTURE_HEIGHT},
@code{GL_TEXTURE_DEPTH}, @code{GL_TEXTURE_BORDER},
@code{GL_TEXTURE_INTERNAL_FORMAT}, @code{GL_TEXTURE_RED_SIZE},
@code{GL_TEXTURE_GREEN_SIZE}, @code{GL_TEXTURE_BLUE_SIZE}, 
@code{GL_TEXTURE_ALPHA_SIZE}, @code{GL_TEXTURE_LUMINANCE_SIZE}, or
@code{GL_TEXTURE_INTENSITY_SIZE}.   This procedure returns an integer.
@end defun

@subheading Mipmaps

@defun glu-build-1d-mipmaps target internal-format width format type texels
@defunx glu-build-2d-mipmaps target internal-format width height format type texels
@defunx glu-build-3d-mipmaps target internal-format width height depth format type texels
Constructs a serids of mipmaps and calls @code{gl-tex-image-*d} to load
the images.  Returns 0 on success, or a GLU error code on failure.
@var{Texels} is a uniform vector, that must be compatible with
@var{format} and @var{type} arguments, and must have the enough length
as specified by @var{width}, @var{height} and @var{depth} parameters.
@end defun

@defun glu-build-1d-mipmap-levels target internal-format width format type level base max texels
@defunx glu-build-2d-mipmap-levels target internal-format width height format type level base max texels
@defunx glu-build-3d-mipmap-levels target internal-format width height depth format type level base max texels
Like @code{glu-build-*d-mipmaps}, but you can specify the level of
@var{texels}, and the range of levels to be generated
by the @var{base} and @var{max} parameters.  It is used to generate
a subset of mipmaps.

Returns 0 on success, or a GLU error code on failure.
@var{Texels} is a uniform vector, that must be compatible with
@var{format} and @var{type} arguments, and must have the enough length
as specified by @var{width}, @var{height} and @var{depth} parameters.
@end defun

@subheading Texture objects

@defun gl-gen-textures size
Returns @var{size} new names for texture objects in a u32vector.
@end defun

@defun gl-is-texture name
Returns @code{#t} if an integer @var{name} is the name of a texture
that has been bound and not deleted yet, @code{#f} otherwise.
@end defun

@defun gl-bind-texture target name
Bind the current texture (specified by @var{target},
e.g. @code{GL_TEXTURE_2D}) to the integer @var{name}.
If there's already a texture bound to @var{name}, it becomes current.
Otherwise a new texture object is created and made current.
@end defun

@defun gl-delete-textures names
Delets textures.  @var{Names} must be a u32vector contains integer names
of the texture objects to be deleted.
@end defun

@defun gl-are-textures-resident! names residences
@var{Names} must be a u32vector contains integer names
of the texture objects, and @var{residences} must be a GL boolean vector
of the same length as @var{names}.  If all textures named in @var{names}
are resident, @code{#t} is returned and @var{residences} is not
modified.  Othewise, @code{#f} is returned and 
@var{residences} is modified to contain @code{#t} if the corresponding
texture in @var{names} is resident, @code{#f} othewise.
@end defun

@defun gl-prioritize-textures names priorities
Sets the prioridies of texture objects named by @var{names} to 
the corresponding entry of @var{priorities}
@var{Names} must be a u32vectore and @var{priorities} must be an f32vector,
and the lengths of both vectors must match.
@end defun

@subheading Texture environment and coordinates

@defun gl-tex-env target pname param
Sets the current texturing function.   @var{Target} must be 
@code{GL_TEXTURE_ENV}.  Possible values of @var{pname} and accepted
@var{param} for each value is as follows.

@table @code
@item GL_TEXTURE_ENV_MODE
One of @code{GL_DECAL}, @code{GL_REPLACE}, @code{GL_MODULATE} or
@code{GL_BLEND}.
@item GL_TEXTURE_ENV_COLOR
f32vector of size 4 to specify the color.
@end table
@end defun

@defun gl-tex-gen coord pname param
Specifies the functions for automatic texture coordinate generation.
@var{Coord} specifies the coordinates, either one of @code{GL_S}, 
@code{GL_T}, @code{GL_R} or @code{GL_Q}.
Possible values of @var{pname} and accepted
@var{param} for each value is as follows.
@table @code
@item GL_TEXTURE_GEN_MODE
Either @code{GL_OBJECT_LINEAR}, @code{GL_EYE_LINEAR} or
@code{GL_SPHERE_MAP}.
@item GL_OBJECT_PLANE
@item GL_EYE_PLANE
An s32, f32 or f64vector of size 4 to specify the plane.
@end table
@end defun

@subheading Multitexturing

@defun gl-active-texture-arb texunit
[GL_ARB_multitexture]
Selects the texture unit that is currently modified by
texturing routines.  @var{Texunit} is a constant 
@code{GL_TEXTUREi_ARB}, where @var{i} is 0 to the maximum
number of the supported texture units.
@end defun

@defun gl-multi-tex-coord-arb texunit coords
@defunx gl-multi-tex-coord-arb texunit s &optional t r q
[GL_ARB_multitexture]
Specifies the texture coordinate of the texture unit @var{texunit}.
In the first form, you can pass either an f32, f64, s32, or s16vector
of length 1 to 4.  In the second form, @var{s}, @var{t}, @var{r}
and @var{q} must be real numbers.
@end defun

@defun gl-client-active-texture-arb texunit
Selects the current texture unit for specifying texutre-coordinate
data with vertex arrays.
@end defun

@c ----------------------------------------------------------------------
@node Framebuffers, Selection and feedback, Texture mapping, OpenGL API
@section Framebuffers

@subheading Clearing buffers

@defun gl-clear-color r g b a
Sets the current clearing color.
Each color value sould be a real number, and is clamped to
@code{[0.0,1.0]}.
@end defun

@defun gl-clear-index c
Sets the current clearing color (in color index mode).
@var{c} must be a real number.  
@end defun

@defun gl-clear-depth depth
Sets the current clearing depth value.
@var{Depth} must be a real number and clamped to @code{[0.0,1.0]}.
@end defun

@defun gl-clear-stencil s
Sets the current clearing value of the stencil buffer.
@end defun

@defun gl-clear-accum r g b a
Sets the current clearing value of accumulation buffer.
@end defun

@defun gl-clear mask
Clears the specified buffer.   @var{Mask} is a logical-or of
the following constants.

@table @code
@item GL_COLOR_BUFFER_BIT
@item GL_DEPTH_BUFFER_BIT
@item GL_ACCUM_BUFFER_BIT
@item GL_STENCIL_BUFFER_BIT
@end table

@end defun

@subheading Selecting color buffers

@defun gl-draw-buffer mode
Selects (a) buffer(s) to which the image is rendered.
Possible @var{mode} values are: @code{GL_FRONT},
@code{GL_FRONT_LEFT}, @code{GL_FRONT_RIGHT},
@code{GL_BACK}, @var{GL_BACK_LEFT}, @var{GL_BACK_RIGHT},
@code{GL_LEFT}, @code{GL_RIGHT}, @code{GL_AUXi},
@code{GL_FRONT_AND_BACK}, and @code{GL_NONE}.
@end defun

@defun gl-read-buffer mode
Selects a color buffer as the source for reading pixels.
Possible @var{mode} values are the same as @code{gl-draw-buffer}
except @code{GL_FRONT_AND_BACK} and @code{GL_NONE}.
@end defun

@subheading Masking buffers

@defun gl-index-mask mask
In color index mode, sets the mask of the color-index buffer.
@var{Mask} is an exact integer.
@end defun

@defun gl-color-mask r g b a
@var{R}, @var{g}, @var{b} and @var{a} are boolean values to
specify whether the corresponding color channel should be written
to the color buffer or not.
@end defun

@defun gl-depth-mask flag
@var{Flag} is a boolean value specifies whether depth buffer should
be written or not.
@end defun

@defun gl-stencil-mask mask
Sets the mask bit pattern for the stencil buffer.  @var{Mask} is 
an exact integer.
@end defun


@subheading Testing and operating on fragments

@defun gl-scissor x y width height
Sets the scissor rectangle.  If the scissor test is enabled
(use @code{(gl-enable GL_SCISSOR_TEST)}), only the pixels that lie inside
the rectangle are written.
@end defun

@defun gl-alpha-func func ref
Sets the reference value and comparison function for the alpha test.
@var{Func} may be either one of @code{GL_NEVER}, @code{GL_ALWAYS},
@code{GL_LESS}, @code{GL_LEQUAL}, @code{GL_EQUAL}, @code{GL_GEQUAL},
@code{GL_GREATER}, or @code{GL_NOTEQUAL}.  @var{Ref} sets the reference
value, a real number clamped to be between 0.0 and 1.0.
@end defun

@defun gl-stencil-func func ref mask
Sets the comparison function, the reference value, and a mask for
stencil test.  @var{Func} specifies the funciton, and its possible
value is the same as @code{gl-alpha-func}'s.  @var{Ref} is an integer
reference value, and @var{mask} is an integer specifying bitwise mask.
Before the comparison, the reference value and the fragment value are
taken bitwise AND by @var{mask}.
@end defun

@defun gl-stencil-op func zfail zpass
Speficies how the stencil buffer should be modified by the result of
the stencil test.  Each three parameter can take one of the following
values independently: @code{GL_KEEP}, @code{GL_ZERO}, @code{GL_REPLACE},
@code{GL_INCR}, @code{GL_DECR}, or @code{GL_INVERT}.
@end defun


@defun gl-depth-func func
Sets the comparison function for the depth test.  @var{Func} may
be one of the following constant value: @code{GL_NEVER}, 
@code{GL_ALWAYS}, @code{GL_LESS}, @code{GL_LEQUAL}, @code{GL_EQUAL},
@code{GL_GEQUAL}, @code{GL_GREATER}, or @code{GL_NOTEQUAL}.
@end defun

@defun gl-depth-range nearv farv
Defines an encoding for z-coordinates.  @var{Nearv} and @var{farv}
define the minimum and maximum values that can be stored in the 
depth buffer.  By default, they're 0.0 and 1.0, respectively.
@end defun

@defun gl-logic-op opcode
Selects the logical operation to be performed, given an incoming
(source) fragment and the pixel currently in the color buffer
(destination).  @var{Opcode} may be one of the following values:
@code{GL_CLEAR}, @code{GL_COPY}, @code{GL_NOOP}, @code{GL_SET},
@code{GL_COPY_INVERTED}, @code{GL_INVERT}, @code{GL_AND_REVERSE},
@code{GL_OR_REVERSE}, @code{GL_AND}, @code{GL_OR}, @code{GL_NAND},
@code{GL_NOR}, @code{GL_XOR}, @code{GL_EQUIV}, @code{GL_AND_INVERTED}
or @code{GL_OR_INVERTED}.
@end defun

@defun gl-accum op value
Sets the accumulation buffer operation mode.  @var{Op} may be
one of the following values:
@table @code
@item GL_ACCUM
Reads each pixel from the current selected buffer to read
(by @code{gl-read-buffer}), multiplies its values by @var{value},
and adds the result into the accumulation buffer.
@item GL_LOAD
Same as @code{GL_ACCUM} but replacing the accumulation buffer by
the result of multiplication, instead of adding it.
@item GL_RETURN
Takes the values from accumulation buffer, multiplies them with @var{value},
then write it to the current color buffer to write (by @code{gl-draw-buffer}).
@item GL_ADD
Adds @var{value} to each pixel in the accumulation buffer and write
it back.
@item GL_MULT
Multiplies @var{value} to each pixel in the accumulation buffer and write
it back.  The result value is clamped to [-1.0, 1.0].
@end table
@end defun


@c ----------------------------------------------------------------------
@node Selection and feedback, Projection, Framebuffers, OpenGL API
@section Selection and feedback

@defun gl-feedback-buffer type buffer
@end defun

@defun gl-select-buffer buffer
@end defun

@defun gl-render-mode mode
@end defun

@defun gl-pass-through token
@end defun

@defun gl-init-names
@end defun

@defun gl-load-name name
@end defun

@defun gl-push-name name
@end defun

@defun gl-pop-name
@end defun



@c ----------------------------------------------------------------------
@node Projection, Quadrics, Selection and feedback, OpenGL API
@section Projection

@defun glu-pick-matrix x y w h vp
@end defun

@defun glu-project objx objy objz model-mat proj-mat vp
@end defun

@defun glu-un-project winx winy winz model-mat proj-mat vp
@end defun

@defun glu-project! win obj model-mat proj-mat vp
@end defun

@defun glu-un-project! obj win model-map proj-mat vp
@end defun

@c ----------------------------------------------------------------------
@node Quadrics, Nurbs, Projection, OpenGL API
@section Quadrics

@deftp {Class} <glu-quadric>
@end deftp

@defun glu-quadric-draw-style quad style

@defvr {Constant} GLU_POINT
@defvrx {Constant} GLU_LINE
@defvrx {Constant} GLU_FILL
@defvrx {Constant} GLU_SILHUETTE
@end defvr

@end defun

@defun glu-quadric-orientation quad orientation

@defvr {Constant} GLU_OUTSIDE
@defvrx {Constant} GLU_INSIDE
@end defvr

@end defun

@defun glu-quadric-normals quad normals

@defvr {Constant} GLU_SMOOTH
@defvrx {Constant} GLU_FLAT
@defvrx {Constant} GLU_NONE
@end defvr

@end defun

@defun glu-quadric-texture quad texcoords
@end defun

@defun glu-cylinder quad base-radius top-radius height slices stacks
@end defun

@defun glu-sphere quad radius slices stacks
@end defun

@defun glu-disk quad inner-radius outer-radius slices loops
@end defun

@defun glu-partial-disk quad inner-radius outer-radius slices loops start-angle sweep-angle
@end defun

@c ----------------------------------------------------------------------
@node Nurbs, Polygon tesselation, Quadrics, OpenGL API
@section Nurbs

@deftp {Class} <glu-nurbs>
@end deftp

@defun glu-load-sampling-matrices nurbs model-matrix proj-matrix viewport
@end defun

@defun glu-nurbs-property nurbs property value
@end defun

@defun glu-get-nurbs-property nurbs property
@end defun

@defun glu-begin-curve nurbs
@end defun

@defun glu-end-curve nurbs
@end defun

@defun glu-nurbs-curve nurbs knot stride ctlarray order type
@end defun

@defun glu-begin-surface nurbs
@end defun

@defun glu-end-surface nurbs
@end defun


@c ----------------------------------------------------------------------
@node Polygon tesselation, Programmable shaders, Nurbs, OpenGL API
@section Polygon tesselation

@deftp {Class} <glu-tesselator>
@end deftp

@c ----------------------------------------------------------------------
@node Programmable shaders,  , Polygon tesselation, OpenGL API
@section Programmable shaders

@subheading Shader objects

@defun gl-create-shader-object-arb type
[GL_ARB_shader_objects]
Creates a new shader object and returns its handle.
@var{Type} can be either @code{GL_VERTEX_SHADER_ARB} or
@code{GL_FRAGMENT_SHADER_ARB}.
@end defun

@defun gl-shader-source-arb shader strings
[GL_ARB_shader_objects]
Sets the source code of the shader, whose handle is @var{shader}.
You can give the source code as a list of strings to @var{strings}.
All strings are concatenated internally in the OpenGL driver.
@end defun

@defun gl-compile-shader-arb shader
[GL_ARB_shader_objects]
Compile the source code attached to the shader, whose handle is @var{shader}.
You can query the result of the compilation by passing
@code{GL_OBJECT_COMPILE_STATUS_ARB} to @code{gl-get-object-parameter-arb};
it returns @code{#t} if the compilation succeeded, or @code{#f} if failed.
The information about the compilation can be obtained by
@code{gl-get-info-log-arb}.
@end defun

@defun gl-create-program-object-arb
[GL_ARB_shader_objects]
Creates a new program object and returns its handle.
@end defun

@defun gl-attach-object-arb program shader
[GL_ARB_shader_objects]
Attach a shader whose handle is @var{shader} to the program whose handle
is @var{program}.
@end defun

@defun gl-detach-object-arb program shader
[GL_ARB_shader_objects]
Detach a shader from a program.
@end defun

@defun gl-link-program-arb program
[GL_ARB_shader_objects]
Link the program object.  The result of linking can be queried
by passing @code{GL_OBJECT_LINK_STATUS_ARB} to
@code{gl-get-object-parameter-arb}.
@end defun

@defun gl-use-program-object-arb program
[GL_ARB_shader_objects]
Installs the program to the current rendering state.
@end defun

@defun gl-delete-object-arb handle
[GL_ARB_shader_objects]
Deletes either a shader object or a program object specified by
@var{handle}.
@end defun

@defun gl-get-object-parameter-arb object pname
[GL_ARB_shader_objects]
Queries the value of @var{pname} of the shader or the program
specified by @var{object}.  The following values are accepted 
as @var{pname}: @code{GL_OBJECT_TYPE_ARB}, 
@code{GL_OBJECT_SUBTYPE_ARB},
@code{GL_OBJECT_DELETE_STATUS_ARB},
@code{GL_OBJECT_COMPILE_STATUS_ARB},
@code{GL_OBJECT_LINK_STATUS_ARB},
@code{GL_OBJECT_VALIDATE_STATUS_ARB},
@code{GL_OBJECT_INFO_LOG_LENGTH_ARB},
@code{GL_OBJECT_ATTACHED_OBJECTS_ARB},
@code{GL_OBJECT_ACTIVE_ATTRIBUTES_ARB}, 
@code{GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB},
@code{GL_OBJECT_ACTIVE_UNIFORMS_ARB},
@code{GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB}, and
@code{GL_OBJECT_SHADER_SOURCE_LENGTH_ARB}.
The procedure returns an integer value.
@end defun

@defun gl-get-shader-source-arb shader
[GL_ARB_shader_objects]
Returns the shader source code of a shader object @var{shader}
in a string.
@end defun

@defun gl-get-info-log-arb handle
[GL_ARB_shader_objects]
Returns the information log of an object pointed by @var{handle}.
@end defun

@defun gl-get-handle-arb pname
[GL_ARB_shader_objects]
Returns the handle to an object that is used in the current state.
The only argument accepted currently as @var{pname} is
@code{GL_PROGRAM_OBJECT_ARB}, which returns the handle to the current
program object.
@end defun

@defun gl-get-attached-objects-arb program
[GL_ARB_shader_objects]
Rethrns a vector of GL object handles that are attached to the @var{program}.
@end defun

@defun gl-validate-program-arb program
[GL_ARB_shader_objects]
Checks whether the @var{program} can execute in the current GL state.
The result is stored in @var{program}'s log.
@end defun

@subheading Specifying vertex attributes

@defun gl-vertex-attrib-arb index values
@defunx gl-vertex-attrib-arb index v0 &rest v1 v2 v3
[GL_ARB_vertex_program]
Sets the generic vertex attribute specified by @var{index}.
In the first form, you can pass f32, f64, or s16vector of size 
1 to 4, or u8, s8, u16, s32, or u32vector of size 4.
In the second form, you can pass 1 to 4 real numbers (they
are interpreted as C doubles and @code{glVertexAttrib4dARB} is called).
@end defun

@defun gl-vertex-attrib-4n-arb index values
@defunx gl-vertex-attrib-4n-arb index v0 v1 v2 v3
[GL_ARB_vertex_program]
These variations can be used to pass normalized values.
The first form accepts s8, u8, s16, u16, s32, u32, f32 and f64vector
of size 4.  The second value takes four integers, whose lower 8bits
are taken as unsigned byte and passed to @code{glVertexAttrib4NubARB}.
@end defun

@defun gl-vertex-attrib-pointer-arb index size vec &optional normalized stride offset
[GL_ARB_vertex_program]
This is the generic version of vertex arrays.  @var{Index} names
the attribute, @var{size} specifies the number of components (1, 2, 3 or 4),
and @var{vec} is a uniform vector that contains the array of values.

The optional boolean @var{normalized} argument tells whether the
passed integer values should be mapped to normalized range (@code{#t} or
taken as are @code{#f}, default).  The optional @var{stride} argument
specifies the gap between each set of values within @var{vec}.
The optional @var{offset} argument tells GL to take values beginning
from the @var{offset}-th element of @var{vec}.
@end defun

@defun gl-enable-vertex-attrib-array-arb index
@defunx gl-disable-vertex-attrib-array-arb index
[GL_ARB_vertex_program]
Enable or disable a vertex attribute array specified by @var{index}.
@end defun

@defun gl-bind-attrib-location-arb program index name
[GL_ARB_vertex_shader]
Associates a user-defined attribute variable in the program object
@var{program} with an @var{index}-th generic vertex attribute.
@var{Name} is a string of the name of user-defined attribute as appears
in the shader program.
@end defun

@defun gl-get-attrib-location-arb program name
[GL_ARB_vertex_shader]
Returns an integer index of the user-defined attribute @var{name}
in the @var{program}.  Must be called after @var{program} is linked.
@end defun

@defun gl-get-active-attrib-arb program index
[GL_ARB_vertex_shader]
Obtains information about the @var{index}-th user-defined attribute
in the @var{program}.  Must be called after @var{program} is linked.

It returns three values: the size of the attribute (1, 2, 3 or 4),
the type of the attribute (an integer that matches one of the following
constants: @code{GL_FLOAT}, @code{GL_FLOAT_VEC2_ARB},
@code{GL_FLOAT_VEC3_ARB}, @code{GL_FLOAT_VEC4_ARB}, 
@code{GL_FLOAT_MAT2_ARB}, @code{GL_FLOAT_MAT3_ARB}, or
@code{GL_FLOAT_MAT4_ARB}.), and
the name of the attribute.
@end defun

@subheading Specifying uniform variables

@defun gl-get-uniform-location-arb program name
[GL_ARB_shader_objects]
Returns an integer location of the uniform variable @var{name}
of the program @var{program}.
@end defun

@defun gl-uniform1-arb location vec
@defunx gl-uniform1-arb location v0
@defunx gl-uniform2-arb location vec
@defunx gl-uniform2-arb location v0 v1
@defunx gl-uniform3-arb location vec
@defunx gl-uniform3-arb location v0 v1 v2
@defunx gl-uniform4-arb location vec
@defunx gl-uniform4-arb location v0 v1 v1 v3
[GL_ARB_shader_objects]
Sets a value of the uniform variable specified by @var{location}.
@var{gl-uniform1-arb} sets a single component value (e.g. @code{float})
@var{gl-uniform2-arb} sets a double component value
(e.g. @code{vec2}) etc.

The first form of each function takes either an s32vector or f32vector.
It can have a size multiple of the number of components to 
set an array uniform variable (e.g. you can pass an f32vector of
size 8 to fill @code{vec2[2]}).

The second form just sets the component(s) of a single uniform variable.
The arguments @var{v0} to @var{v3} must be real numbers, and 
coerced to C @code{float} (i.e. @code{glUniform*fARB} is used).
@end defun


@defun gl-uniform-matrix2-arb location transpose v
@defunx gl-uniform-matrix3-arb location transpose v
@defunx gl-uniform-matrix4-arb location transpose v
[GL_ARB_shader_objects]
Sets a matrix uniform variable (or an array of matrix uniform variables)
specified by @var{location}.
A boolean flag @var{transpose} specifies whether the matrix should be 
transposed.
The @var{v} argument must be a f32vector of size multiple of 4, 9, or
16, respectively.
@end defun

@defun gl-get-active-uniform-arb program index
[GL_ARB_shader_objects]
Returns informaton about the @var{index}-th uniform variable of
@var{program}.

Returns three values.  The first one is the size, either 1, 2, 3 or 4.
The second value is the type, which is an integer that matches
one of the following constants: @code{GL_FLOAT}, 
@code{GL_FLOAT_VEC(1|2|3|4)_ARB}, @code{GL_INT}, 
@code{GL_INT_VEC(1|2|3|4)_ARB}, @code{GL_BOOL}, 
@code{GL_BOOL_VEC(1|2|3|4)_ARB}, @code{GL_FLOAT_MAT(2|3|4)_ARB}.
And the third value is the name of the uniform variable.
@end defun

@subheading Vertex and fragment programs

These APIs are for low-level vertex/fragment pipeline programming.

@defun gl-gen-programs-arb n
[GL_ARB_vertex_program]
Generates @var{N} names (integers) for the new programs and
returns them in an s32vector.
@end defun

@defun gl-delete-programs-arb programs
[GL_ARB_vertex_program]
Deletes programs whose names are specified by an s32vector @var{programs}.
@end defun

@defun gl-is-program-arb prog-id
[GL_ARB_vertex_program]
Returns @code{#t} if an integer @var{prog-id} refers to a valid program.
@end defun

@defun gl-bind-program-arb target prog-id
[GL_ARB_vertex_program]
Binds a program specified by @var{prog-id} to a @var{target},
which is either @code{GL_VERTEX_PROGRAM_ARB} or 
@var{GL_FRAGMENT_PROGRAM_ARB}.
@end defun

@defun gl-program-string-arb target format text
[GL_ARB_vertex_program]
Sets the source code of the program currently bound to the
@var{target} (@code{GL_VERTEX_PROGRAM_ARB} or 
@var{GL_FRAGMENT_PROGRAM_ARB}).

@var{Format} must be @code{GL_PROGRAM_FORMAT_ASCII_ARB}.
@var{Text} is a string for the program source.
@end defun

@defun gl-program-env-parameter-arb target param-id args
@defunx gl-program-env-parameter-arb target param-id arg0 arg1 arg2 arg3
@defunx gl-program-local-parameter-arb target param-id args
@defunx gl-program-local-parameter-arb target param-id arg0 arg1 arg2 arg3
[GL_ARB_vertex_program]
Sets the value of the environment and local parameter
specified by @var{param-id} of the program currently bount to the @var{target}.
In the first form of each, @var{args} must be either f32 or
f64vector of size 4 or @code{<vector4f>} object.
@end defun


@c ======================================================================
@node GLUT API, Vectors and matrices, OpenGL API, Top
@chapter GLUT API

@c ----------------------------------------------------------------------
@menu
* GLUT window manipulation::    
* GLUT overlay::                
* GLUT menu API::               
* GLUT callbacks::              
* GLUT colormap::               
* GLUT state retrieval::        
* GLUT font::                   
* GLUT pre-built models::       
@end menu

@node GLUT window manipulation, GLUT overlay, GLUT API, GLUT API
@section GLUT window manipulation

@defun glut-init args
@end defun

@defun glut-init-display-mode mode
@end defun

@defvr {Constant} GLUT_RGB
@defvrx {Constant} GLUT_RGBA
@defvrx {Constant} GLUT_INDEX
@defvrx {Constant} GLUT_SINGLE
@defvrx {Constant} GLUT_DOUBLE
@defvrx {Constant} GLUT_ACCUM
@defvrx {Constant} GLUT_ALPHA
@defvrx {Constant} GLUT_DEPTH
@defvrx {Constant} GLUT_STENCIL
@defvrx {Constant} GLUT_MULTISAMPLE
@defvrx {Constant} GLUT_STEREO
@defvrx {Constant} GLUT_LUMINANCE
@end defvr

@defun glut-init-display-string string
@end defun

@defun glut-init-window-size width height
@end defun

@defun glut-init-window-position x y
@end defun

@defun glut-main-loop
@end defun

@defun glut-create-widnow name
@end defun

@defun glut-create-sub-window win x y width height
@end defun

@defun glut-destroy-window win
@end defun

@defun glut-post-redisplay
@end defun

@defun glut-post-window-redisplay win
@end defun

@defun glut-swap-buffers
@end defun

@defun glut-get-window
@end defun

@defun glut-set-window win
@end defun

@defun glut-set-window-title title
@end defun

@defun glut-set-icon-title title
@end defun

@defun glut-position-window x y
@end defun

@defun glut-reshape-window width height
@end defun

@defun glut-push-window
@defunx glut-pop-window
@end defun

@defun glut-iconify-window
@end defun

@defun glut-show-window
@defunx glut-hide-window
@end defun

@defun glut-full-screen
@end defun

@defun glut-set-cursor cursor
@end defun

@defvr {Constant} GLUT_CURSOR_RIGHT_ARROW
@defvrx {Constant} GLUT_CURSOR_LEFT_ARROW
@defvrx {Constant} GLUT_CURSOR_INFO
@defvrx {Constant} GLUT_CURSOR_DESTROY
@defvrx {Constant} GLUT_CURSOR_HELP
@defvrx {Constant} GLUT_CURSOR_CYCLE
@defvrx {Constant} GLUT_CURSOR_SPRAY
@defvrx {Constant} GLUT_CURSOR_WAIT
@defvrx {Constant} GLUT_CURSOR_TEXT
@defvrx {Constant} GLUT_CURSOR_CROSSHAIR
@defvrx {Constant} GLUT_CURSOR_UP_DOWN
@defvrx {Constant} GLUT_CURSOR_LEFT_RIGHT
@defvrx {Constant} GLUT_CURSOR_TOP_SIDE
@defvrx {Constant} GLUT_CURSOR_BOTTOM_SIDE
@defvrx {Constant} GLUT_CURSOR_LEFT_SIDE
@defvrx {Constant} GLUT_CURSOR_RIGHT_SIDE
@defvrx {Constant} GLUT_CURSOR_TOP_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_TOP_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_INHERIT
@defvrx {Constant} GLUT_CURSOR_NONE
@defvrx {Constant} GLUT_CURSOR_FULL_CROSSHAIR
@end defvr


@defun glut-warp-pointer x y
@end defun

@c ----------------------------------------------------------------------
@node GLUT overlay, GLUT menu API, GLUT window manipulation, GLUT API
@section GLUT overlay

@defun glut-establish-overlay
@end defun

@defun glut-remove-overlay
@end defun

@defun glut-use-layer layer
@end defun

@defun glut-post-overlay-redisplay
@end defun

@defun glut-post-window-overlay-redisplay win
@end defun

@defun glut-show-overlay
@end defun

@defun glut-hide-overlay
@end defun

@c ----------------------------------------------------------------------
@node GLUT menu API, GLUT callbacks, GLUT overlay, GLUT API
@section GLUT menu API

@defun glut-create-menu callback
@end defun

@defun glut-destroy-menu menu
@end defun

@defun glut-get-emnu
@end defun

@defun glut-set-menu menu
@end defun

@defun glut-add-menu-entry label value
@end defun

@defun glut-add-sub-menu label submenu
@end defun

@defun glut-change-to-menu-entry item label value
@end defun

@defun glut-change-to-sub-menu item label submenu
@end defun

@defun glut-remove-menu-item item
@end defun

@defun gult-attach-menu button
@end defun

@defun glut-detach-menu button
@end defun

@c ----------------------------------------------------------------------
@node GLUT callbacks, GLUT colormap, GLUT menu API, GLUT API
@section GLUT callbacks

@defun glut-display-func fn
@end defun

@defun glut-reshape-func fn
@end defun

@defun glut-keyboard-func fn
@end defun

@defvr {Constant} GLUT_KEY_F1
@defvrx {Constant} GLUT_KEY_F2
@defvrx {Constant} GLUT_KEY_F3
@defvrx {Constant} GLUT_KEY_F4
@defvrx {Constant} GLUT_KEY_F5
@defvrx {Constant} GLUT_KEY_F6
@defvrx {Constant} GLUT_KEY_F7
@defvrx {Constant} GLUT_KEY_F8
@defvrx {Constant} GLUT_KEY_F9
@defvrx {Constant} GLUT_KEY_F10
@defvrx {Constant} GLUT_KEY_F11
@defvrx {Constant} GLUT_KEY_F12
@defvrx {Constant} GLUT_KEY_LEFT
@defvrx {Constant} GLUT_KEY_UP
@defvrx {Constant} GLUT_KEY_RIGHT
@defvrx {Constant} GLUT_KEY_DOWN
@defvrx {Constant} GLUT_KEY_PAGE_UP
@defvrx {Constant} GLUT_KEY_PAGE_DOWN
@defvrx {Constant} GLUT_KEY_HOME
@defvrx {Constant} GLUT_KEY_END
@defvrx {Constant} GLUT_KEY_INSERT
@end defvr


@defun glut-mouse-func fn
@end defun

@defvr {Constant} GLUT_LEFT_BUTTON
@defvrx {Constant} GLUT_MIDDLE_BUTTON
@defvrx {Constant} GLUT_RIGHT_BUTTON
@defvrx {Constant} GLUT_DOWN
@defvrx {Constant} GLUT_UP
@end defvr

@defun glut-motion-func fn
@end defun

@defun glut-passive-motion-func fn
@end defun

@defun glut-entry-func fn
@end defun

@defvr {Constant} GLUT_LEFT
@defvrx {Constant} GLUT_ENTERED
@end defvr

@defun glut-visibility-func fn
@end defun

@defvr {Constant} GLUT_NOT_VISIBLE
@defvrx {Constant} GLUT_VISIBLE
@end defvr

@defun glut-idle-func fn
@end defun

@defun glut-timer-func millis fn value
@end defun

@defun glut-menu-state-func fn
@end defun

@defun glut-special-func fn
@end defun

@defun glut-spaceball-motion-func fn
@end defun

@defun glut-spaceball-rotate-func fn
@end defun

@defun glut-spaceball-button-func fn
@end defun

@defun glut-button-box-func fn
@end defun

@defun glut-dials-func fn
@end defun

@defun glut-tablet-motion-func fn
@end defun

@defun glut-tablet-button-func fn
@end defun

@defun glut-menu-status-func fn
@end defun

@defun glut-overlay-dislay-func fn
@end defun

@defun glut-window-status-func fn
@end defun

@defun glut-keyboard-up-func fn
@end defun

@defun glut-special-up-func fn
@end defun

@defun glut-joystick-func fn interval
@end defun

@c ----------------------------------------------------------------------
@node GLUT colormap, GLUT state retrieval, GLUT callbacks, GLUT API
@section GLUT colormap

@defun glut-set-color index r g b
@end defun

@defun glut-get-color index component
@end defun

@defvr {Constant} GLUT_RED
@defvrx {Constant} GLUT_GREEN
@defvrx {Constant} GLUT_BLUE
@end defvr

@defun glut-copy-colormap win
@end defun

@c ----------------------------------------------------------------------
@node GLUT state retrieval, GLUT font, GLUT colormap, GLUT API
@section GLUT state retrieval

@defun glut-get type
@end defun

@defvr {Constant} GLUT_WINDOW_X
@defvrx {Constant} GLUT_WINDOW_Y
@defvrx {Constant} GLUT_WINDOW_WIDTH
@defvrx {Constant} GLUT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_WINDOW_BUFFER_SIZE
@defvrx {Constant} GLUT_WINDOW_STENCIL_SIZE
@defvrx {Constant} GLUT_WINDOW_DEPTH_SIZE
@defvrx {Constant} GLUT_WINDOW_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_DOUBLEBUFFER
@defvrx {Constant} GLUT_WINDOW_RGBA
@defvrx {Constant} GLUT_WINDOW_PARENT
@defvrx {Constant} GLUT_WINDOW_NUM_CHILDREN
@defvrx {Constant} GLUT_WINDOW_COLORMAP_SIZE
@defvrx {Constant} GLUT_WINDOW_NUM_SAMPLES
@defvrx {Constant} GLUT_WINDOW_STEREO
@defvrx {Constant} GLUT_WINDOW_CURSOR
@defvrx {Constant} GLUT_SCREEN_WIDTH
@defvrx {Constant} GLUT_SCREEN_HEIGHT
@defvrx {Constant} GLUT_SCREEN_WIDTH_MM
@defvrx {Constant} GLUT_SCREEN_HEIGHT_MM
@defvrx {Constant} GLUT_MENU_NUM_ITEMS
@defvrx {Constant} GLUT_DISPLAY_MODE_POSSIBLE
@defvrx {Constant} GLUT_INIT_WINDOW_X
@defvrx {Constant} GLUT_INIT_WINDOW_Y
@defvrx {Constant} GLUT_INIT_WINDOW_WIDTH
@defvrx {Constant} GLUT_INIT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_INIT_DISPLAY_MODE
@defvrx {Constant} GLUT_ELAPSED_TIME
@defvrx {Constant} GLUT_WINDOW_FORMAT_ID
@end defvr

@defun glut-device-get type
@end defun

@defvr {Constant} GLUT_HAS_KEYBOARD
@defvrx {Constant} GLUT_HAS_MOUSE
@defvrx {Constant} GLUT_HAS_SPACEBALL
@defvrx {Constant} GLUT_HAS_DIAL_AND_BUTTON_BOX
@defvrx {Constant} GLUT_HAS_TABLET
@defvrx {Constant} GLUT_NUM_MOUSE_BUTTONS
@defvrx {Constant} GLUT_NUM_SPACEBALL_BUTTONS
@defvrx {Constant} GLUT_NUM_BUTTON_BOX_BUTTONS
@defvrx {Constant} GLUT_NUM_DIALS
@defvrx {Constant} GLUT_NUM_TABLET_BUTTONS
@defvrx {Constant} GLUT_DEVICE_IGNORE_KEY_REPEAT
@defvrx {Constant} GLUT_DEVICE_KEY_REPEAT
@defvrx {Constant} GLUT_HAS_JOYSTICK
@defvrx {Constant} GLUT_OWNS_JOYSTICK
@defvrx {Constant} GLUT_JOYSTICK_BUTTONS
@defvrx {Constant} GLUT_JOYSTICK_AXES
@defvrx {Constant} GLUT_JOYSTICK_POLL_RATE
@end defvr

@defun glut-extension-supported name
@end defun

@defun glut-get-modifiers 
@end defun

@defvr {Constant} GLUT_ACTIVE_SHIFT
@defvrx {Constant} GLUT_ACTIVE_CTRL
@defvrx {Constant} GLUT_ACTIVE_ALT
@end defvr

@defun glut-layer-get type
@end defun

@defvr {Constant} GLUT_OVERLAY_POSSIBLE
@defvrx {Constant} GLUT_LAYER_IN_USE
@defvrx {Constant} GLUT_HAS_OVERLAY
@defvrx {Constant} GLUT_TRANSPARENT_INDEX
@defvrx {Constant} GLUT_NORMAL_DAMAGED
@defvrx {Constant} GLUT_OVERLAY_DAMAGED
@end defvr

@c ----------------------------------------------------------------------
@node GLUT font, GLUT pre-built models, GLUT state retrieval, GLUT API
@section GLUT font

@deftp {Class} <glut-font>
@clindex glut-font
@end deftp

@defun glut-bitmap-character font character
@end defun

@defun glut-bitmap-width font character
@end defun

@defun glut-stroke-character font character
@end defun

@defun glut-stroke-width font character
@end defun

@defun glut-bitmap-length font string
@end defun

@defun glut-stroke-length font string
@end defun

@c ----------------------------------------------------------------------
@node GLUT pre-built models,  , GLUT font, GLUT API
@section GLUT pre-built models

@defun glut-wire-sphere radius slices stacks
@defunx glut-solid-sphere radius slices stacks
@end defun

@defun glut-wire-cone radius height slices stacks
@defunx glut-solid-cone radius height slices stacks
@end defun

@defun glut-wire-cube size
@defunx glut-solid-cube size
@end defun

@defun glut-wire-torus inner outer sides rings
@defunx glut-solid-torus inner outer sides rings
@end defun

@defun glut-wire-dodecahedron 
@defunx glut-solid-dodecahedron
@end defun

@defun glut-wire-teapot size
@defunx glut-soild-teapot size
@end defun

@defun glut-wire-octahedron
@defunx glut-solid-octahedron
@end defun

@defun glut-wire-tetrahedron
@defunx glut-solid-tetrahedron
@end defun

@defun glut-wire-icosahedron
@defunx glut-solid-icosahedron
@end defun


@c ======================================================================
@node Vectors and matrices, Simple utilities, GLUT API, Top
@chapter Vectors and matrices

@deftp {Module} gl.math3d
@mdindex gl.math3d
The module provides vector and matrix operations useful for
3D computer graphics.

Actually this module itself doesn't depend on GL; you can use
this module alone to do matrix calculations.  However, the structure
of objects are designed so that they can be passed directly to
Gauche-gl functions, reducing the overhead of type conversions.

The purpose of this module is to provide reasonable performance.
So the operations are fixed to 3D homogeneous coordinates,
i.e. a vector is 4-element column vector, and a matrix is 4x4
square matrix.  If you want more flexibility, @code{<array>}
class in @code{gauche.array} provides much more generic
structures, trading performance.

Elements of vectors and matrices are represented in @code{float}
internally.   When you retrieve each element individually, 
it is converted to @code{double}, so you might see some precision
errors.   There are lots of operations directly manipulate group of
elements without retrieving each element to Scheme world, avoiding
overhead of conversion.
@end deftp

@c ----------------------------------------------------------------------
@menu
* Vectors and points::          
* Vector arrays and point arrays::  
* Matrices::                    
* Quaternions::                 
@end menu

@node Vectors and points, Vector arrays and point arrays, Vectors and matrices, Vectors and matrices
@section Vectors and points

@deftp {Class} <vector4f>
@deftpx {Class} <point4f>
@clindex vector4f
@clindex point4f
4x1 column vectors.  @code{Vector4f} is intended to be used
to represent a vector, and @code{point4f} is to a point,
but as far as OpenGL concerns, both are just an array of four floats,
@var{x}, @var{y}, @var{z} and @var{w}.

These classes inherit @code{<sequence>} and @code{<collection>}
classes.  So if you import @code{gauche.sequence} module,
you can use generic function such as @code{ref} and @code{(setter ref)}
to get/set individual elements.  The generic version of 
@code{map} and @code{for-each} can also be used on the vector4f and
point4f instances.

Aside from the type, 
the only difference is that the default value of @var{w} component---
it's 0.0 for vectors, and 1.0 for points.  So usual transformation
produces expected results; for example point plus vector
becomes point, vector plus vector becomes vector,
and translating point changes its coordinates but
translating vectors doesn't, and so on.
However, you can set @var{w} component to other value to do 
nontrivial operations.
@end deftp

@deftp {Reader syntax} @code{#,(vector4f @var{x} @var{y} @var{z} @var{w})}
@deftpx {Reader syntax} @code{#,(point4f @var{x} @var{y} @var{z} @var{w})}
These SRFI-10 syntax can be used to denote literal @code{<vector4f>}
and @code{<point4f>} instance, respectively.

The write methods are defined so that the instance is written out
in this form, and can be read back later.
@end deftp

@defun vector4f? obj
@defunx point4f? obj
Returns true iff @var{obj} is vector4f and point4f, respectively.
@end defun


@defun vector4f x y z &optional (w 0.0)
@defunx point4f x y z &optional (w 1.0)
Creates a vector4f and point4f instance with given values, respectively.
@end defun

@defun make-vector4f
@defunx make-point4f
Another way to create a vector4f and a point4f.
The first returns @code{#,(vector4f 0.0 0.0 0.0 0.0)},
and the latter returns @code{#,(point4f 0.0 0.0 0.0 1.0)}.
@end defun

@defun list->vector4f l
@defunx list->point4f l
Convert a list of three or four real numbers to a vector4f and a point4f,
respectively.
If @var{l} is not a list of three or four real numbers, an error is
signalled.

@example
(list->vector4f l)
  @equiv{} (apply vector4f l)
  @equiv{} (coerce-to <vector4f> l)
@end example
@end defun

@defun vector4f->list v
@defunx point4f->list p
Convert a vector4f and a point4f to a list of four real numbers,
respectively.

@example
(vector4f->list v)
  @equiv{} (coerce-to <list> v)
  @equiv{} (map (cut ref v <>) (iota 4))
@end example
@end defun

@defun f32vector->vector4f v &optional start
@defunx f32vector->point4f v &optional start
Creates a vector4f or a point4f, initializing by the elements of
f32vector @var{v}.   @var{V} must be at least 4 elements long, and the first
four elements are used to initialize the created vector or point.

If optional @var{start} argument is given, it specifies an index
of @var{v} from which the initial values are taken; that is,
@var{start}, @var{start+1}, @var{start+2} and @var{start+3}-th
elements are used to create a vector or a point.
This allows to create vectors from plain float array:
@example
(map (lambda (off) (f32vector->vector4f vec (* off 4)))
     (iota (/ (size-of vec) 4)))
@end example

The conversion can be done using @code{coerce-to}, as well.
@example
(f32vector->vector4f vec)
  @equiv{} (coerce-to <vector4f> vec)
@end example
@end defun

@defun vector4f->f32vector v
@defunx point4f->f32vector p
Convert a vector4f @var{v} or a point4f @var{p} to four-element
f32vector.

@example
(vector4f->f32vector v)
 @equiv{} (coerce-to <f32vector> v)
@end example
@end defun

@defun vector4f-copy v
@defunx point4f-copy p
Returns a new copy of vector4f @var{v} or point4f @var{p}, respectively.
@end defun

@defun vector4f-copy! dstv srcv
@defunx point4f-copy! dstp srcp
Destructively sets the content of @var{srcv} or @var{srcp} to
@var{dstv} or @var{dstp}, respectively.
@end defun

@defun vector4f-set! v k value
@defunx point4f-set! p k value
Sets a real number @var{value} to
@var{k}-th element of a vector4f @var{v} or a point4f @var{p}.

@example
(vector4f-set! v k value)
  @equiv{} (set! (ref v k) value)
@end example
@end defun

@defun vector4f-ref v k &optional fallback
@defunx point4f-ref p k &optional fallback
Gets a value of @var{k}-th element of a vector4f @var{v} or
a point4f @var{p}.  If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-ref v k)
  @equiv{} (ref v k)
@end example
@end defun

@defun vector4f-dot x y
Returns a dot product of two vector4fs, @var{x} and @var{y}.
@end defun

@defun vector4f-cross x y
Returns a cross product of two vector4fs, @var{x} and @var{y}.
(@var{w} element is ignored).
@end defun

@defun vector4f-norm v
Returns the norm (length) of the vector @var{v}.
@end defun

@defun vector4f-normalize x
@defunx vector4f-normalize! x
Returns a normalized vector of vector4f @var{x}.
@code{Vector4f-normalize} allocates a new vector, while
@code{vector4f-normalize!} modifies the original vector.

As a special case, 
if @var{x} is a vector of length 0, a vector of length 0 is returned.
@end defun

@defun vector4f-add x y
@defunx vector4f-sub x y
@defunx vector4f-add! x y
@defunx vector4f-sub! x y
Returns a sum of two vector4fs, @var{x} and @var{y}.
The destructive version modifies @var{x}.
@end defun

@defun point4f-add x y
@defunx point4f-add! x y
Adds a point4f @var{x} and a vector4f @var{y}, and returns
a translated point.  The destructive version modifies @var{x}.
@end defun

@defun point4f-sub x y
Subtracts either a vector4f or a point4f @var{y} from
a point4f @var{x}.  If @var{y} is a vector4f, returns 
a translated point.  If @var{y} is a point4f, returns
a vector4f from point @var{y} to point @var{x}.
@end defun

@c ----------------------------------------------------------------------
@node Vector arrays and point arrays, Matrices, Vectors and points, Vectors and matrices
@section Vector arrays and point arrays

@deftp {Class} <vector4f-array>
@deftpx {Class} <point4f-array>
@clindex vector4f-array
@clindex point4f-array
Represents an array of vector4fs and point4fs.
This is an efficient way to keep an array of vectors or points,
for the elements are packed in a simple float array.
They are especially useful to work with GL's vertex array feature.
@code{gl-vertex-pointer} can take @code{<point4f-array>},
and @code{gl-normal-pointer} can take @code{<vector4f-array>}.

It is also possible to "view" a plain f32vector as @code{<vector4f-array>}
or @code{<point4f-array>} without copying its content, by
@code{f32vector->vector4f-array/shared} and
@code{f32vector->point4f-array/shared}.   Combined to
@code{read-block!}, you can do efficient binary I/O of
vertex arrays, for example.

Inherits @code{<sequence>} and @code{<collection>}.
When viewed as a sequence or a collection, they behaves like
sequence or collection of @code{vector4f} and @code{point4f} objects,
respectively.
@end deftp

@defun make-vector4f-array len &optional init-vector
@defunx make-point4f-array len &optional init-point
Creates a vector4f-array or point4f-array with @var{len} elements.
Each element is initialized by a vector4f @var{init-vector} or
a point4f @var{init-point} if provided.
@end defun

@defun vector4f-array? obj
@defunx point4f-array? obj
Returns true iff @var{obj} is a vector4f-array or a point4f-array,
respectively.
@end defun

@defun vector4f-array-length array
@defunx point4f-array-length array
Returns length (number of vectors/points) in array @var{array}.
@end defun

@deftp {Reader syntax} @code{#,(vector4f-array @var{len} @var{elt} @dots{})}
@deftpx {Reader syntax} @code{#,(point4f-array @var{len} @var{elt} @dots{})}
Vector4f-array and point4f-array have external representation
using this SRFI-10 syntax.  @var{Len} is a length of array,
and each @var{elt} is a list of four floats representing
each element of the array.

@example
(f32vector->vector4f-array #f32(1 2 3 4 6 7 4 3))
  @result{} #,(vector4f-array 2 (1 2 3 4) (6 7 4 3) )
@end example
@end deftp

@defun list->vector4f-array list
@defunx list->point4f-array list
From given list of vector4fs or point4fs, creates and returns
a vector4f-array or point4f-array, respectively.
@end defun

@defun f32vector->vector4f-array v
@defunx f32vector->point4f-array v
Converts f32vector @var{v} to a vector4f-array or a point4f-array.
The length of @var{v} must be multiple of four.
The content of @var{v} is copied.

@example
(f32vector->vector4f-array v)
  @equiv{} (coerce-to <vector4f-array> v)
@end example
@end defun

@defun f32vector->vector4f-array/shared v
@defunx f32vector->point4f-array/shared v
Like above, but the content of @var{v} is shared by the result
array, instead of being copied.
So the modification of result array will be visible from original
f32vector @var{v} and vice versa.
It will allow efficient handling of large vertex arrays.
@end defun

@defun vector4f-array->f32vector array
@defunx point4f-array->f32vector array
Converts a vector4f-array or a point4f-array @var{array} to a f32vector.

@example
(vector4f-array->f32vector array)
  @equiv{} (coerce-to <f32vector> array)
@end example
@end defun

@defun vector4f-array-set! array i vector
@defunx point4f-array-set! array i point
Sets a vector4f @var{vector} or a point4f @var{point} to
@var{i}-th element of vector4f-array or point4f-array @var{array},
respectively.

@example
(vector4f-array-set! array i vector)
  @equiv{} (set! (ref array i) vector)
@end example
@end defun

@defun vector4f-array-ref array i &optional fallback
@defunx point4f-array-ref array i &optional fallback
Returns a vector4f or a point4f which is the @var{i}-th element
of array @var{array}, respectively.
If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-array-ref array i)
  @equiv{} (ref array i)

(ref #,(vector4f-array 2 (1 2 3 4) (6 7 4 3))  1)
  @result{} #,(vector4f 6 7 4 3)
@end example
@end defun

@defun vector4f-array-ref/shared array i &optional fallback
@defunx point4f-array-ref/shared array i &optional fallback
Like above, but the returned vector4f or point4f shares the storage
with the original array.  Thus the modification of the result
vector or point will be visible from @var{array}, and vice versa.
@end defun

@c ----------------------------------------------------------------------
@node Matrices, Quaternions, Vector arrays and point arrays, Vectors and matrices
@section Matrices

@deftp {Class} <matrix4f>
@clindex matrix4f
4x4 matrix.  Internally it is represented as an array of 16 floats,
stored in column-major order.
(It is the same order OpenGL uses, so it can be passed to OpenGL
calls without overhead).

Inherits @code{<sequence>} and @code{<collection>}.
When a matrix4f is treated as a sequence, it works as if it is 
a single sequence of floats in column-major order.
@end deftp

@defun make-matrix4f &optional init
Returns a new matrix4f instance.  If @var{init} is omitted,
the matrix is a unit matrix.  Otherwise, @var{init} must be a f32vector
of length 16, and the elements in the matrix is initialized by
ones in f32vector.

@example
;; Creates a matrix like this:
;;    1 2 3 4
;;    0 1 0 5
;;    0 0 1 6
;;    0 0 0 1

(make-matrix4f '#f32vector(1 0 0 0
                           2 1 0 0
                           3 0 1 0
                           4 5 6 1))
@end example
@end defun

@defun matrix4f m00 m10 m20 m30 m01 m11 m21 m31 m02 m12 m22 m32 m03 m13 m23 m33
Creates a new matrix4f instance with give values.
@end defun

@defun matrix4f? obj
Returns true iff @var{obj} is a matrix4f.
@end defun

@deftp {Reader syntax} @code{#,(matrix4f @var{elt} @dots{})}
A matrix4f is represented extrenally using SRFI-10 syntax.
The elements are listed in column-major order.
@end deftp

@defun list->matrix4f l
@defunx matrix4f->list m
Converts between list of 16 real numbers and matrix4f.
@end defun

@defun f32vector->matrix4f v &optional start
Creates a new matrix4f and initializes it with 16 elements in
f32vector @var{v}.   If optional @var{start} is given,
it specifies the start offset in vector @var{v} to be used as
initial values.  The f32vector @var{v} must have enough length.
@end defun

@defun f32vector->matrix4f! m v &optional (start 0)
Extract 16 flonums in the f32vector @var{v} starting from the
index @var{start}, and fill the matrix4f @var{m} with them.
The f32vector @var{v} must have enough length.
@end defun

@defun matrix4f->f32vector m
Returns a new f32vector that has elements from matrix4f @var{m}.
@end defun

@defun matrix4f-copy m
Returns a new copy of @var{m}.
@end defun

@defun matrix4f-copy! dstm srcm
Copies contents of @var{srcm} to @var{dstm}.
@end defun

@defun matrix4f-set! m i value
Sets a real number @var{value} to @var{i}-th element of matrix @var{m}.
Since the matrix is laid out in column-major order,
the one-dimensional index @code{m@{@var{i}@}} and two-dimensional
index @code{m(@var{i},@var{j})} corresponds as follows:
@example
  m(0,0) = m@{0@}   m(0,1) = m@{4@}   m(0,2) = m@{8@}   m(0,3) = m@{12@}
  m(1,0) = m@{1@}   m(1,1) = m@{5@}   m(1,2) = m@{9@}   m(1,3) = m@{13@}
  m(2,0) = m@{2@}   m(2,1) = m@{6@}   m(2,2) = m@{10@}  m(2,3) = m@{14@}
  m(3,0) = m@{3@}   m(3,1) = m@{7@}   m(3,2) = m@{11@}  m(3,3) = m@{15@}
@end example
@end defun

@defun matrix4f-ref m i &optional fallback
Returns the @var{i}-th element of matrix @var{m}.
If @var{i} is out of range, an error is signalled,
unless @var{fallback} is provided, in such a case
@var{fallback} is returned.
@end defun

@defun matrix4f-set2! m i j value
Sets @var{value} to @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-ref2 m i j
Returns the @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-row m i
@defunx matrix4f-column m i
@defunx matrix4f-column/shared m i
Returns @var{i}-th row vector or @var{i}-th column vector
of matrix @var{m}, as a vector4f instance.

Furthermore, the returned vector from @code{matrix4f-column/shared}
shares the storage with @code{m}.
@end defun

@defun matrix4f-mul m obj
@var{Obj} may be a scalar (real number), a vector4f, a point4f, or a matrix4f.
Returns @var{m} x @var{obj}.
@end defun

@defun matrix4f-mul! m obj
@var{Obj} may be a scalar or a matrix4f.
Matrix @var{m} is multiplied by @var{obj}, and the result is
set to @var{m} destructively.
@end defun

@defun matrix4f-transpose m
@defunx matrix4f-transpose! m
Returns a transposed matrix of @var{m}.  The destructive version
modifies @var{m}.
@end defun

@defun matrix4f-determinant m
Returns a determinant of @var{m}.
@end defun

@defun matrix4f-inverse m &optional (error-on-singular? #t)
@defunx matrix4f-inverse! m &optional (error-on-singular? #t)
Returns a inverse matrix of @var{m}.  The destructive version
modifies @var{m}.  If given @var{m} is a singular matrix,
an error is signalled by default.  However, if @code{#f} is given
to the optional @var{error-on-singular?} argument,
@code{#f} is returned in such a case.
@end defun

@defun translation->matrix4f translation-vector
@defunx translation->matrix4f! m translation-vector
Returns a matrix which represents a translation by @var{translation-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.   Only the first three elements
in @var{translation-vector} is used.
The destructive version updates @var{m}.
@end defun

@defun rotation->matrix4f axis angle
@defunx rotation->matrix4f! m axis angle
Returns a matrix which represents a rotation around
@var{axis} by @var{angle} radian.  @var{Axis} must be
a vector4f or a f32vector of length 3 or 4, and must be normalized.
The result is undefined if anormalized vector is passed as @var{axis}.
The destructive version updates @var{m}.
@end defun

@defun scale->matrix4f scale-vector
@defunx scale->matrix4f! m scale-vector
Returns a matrix which represents a scale by @var{scale-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.  Only the first three elements
in @var{scale-vector} is used.  Each element of @var{scale-vector}
represents the scale factor along x, y, and z axis.
The destructive version updates @var{m}.
@end defun

@defun trs->matrix4f translation rotation-axis rotation-angle scale
@defunx trs->matrix4f! m translation rotation-axis rotation-angle scale
This combines above three procedure.
Returns a matrix that represents translation, rotation and
scale, specified by @var{translation}, @var{rotation-axis},
@var{rotation-angle} and @var{scale}.
The destructive version updates @var{m}.

If @code{@i{T}}, @code{@i{R}} and @code{@i{S}}, are
the matrices that represent translation, rotation and scale, respectively,
then these procedures effectively calculates
a matrix @code{@i{TRS}}. 
@end defun

@defun tqs->matrix4f translation rotation-quat scale
@defunx tqs->matrix4f! m translation rotation-quat scale
A variation of @code{trs->matrix4f}.  Instead of axis and angle,
rotation is represented by a quaternion @var{rotation-quat}.
@xref{Quaternions}, for more details about quaternions.
@end defun

@defun euler-angle->matrix4f xangle yangle zangle &optional order
@defunx euler-angle->matrix4f! m xangle yangle zangle &optional order
Returns a matrix that represents rotation along x, y and z axis
by @var{xangle}, @var{yangle}, and @var{zangle}, respectively.

The order of rotation can be specified by the optional argument
@var{order}, which may be one of the symbols @code{xyz}, @code{xzy},
@code{yzx}, @code{yxz}, @code{zxy}, or @code{zyx}.  For example,
symbol @code{xyz} means rotation around x-axis, then y-axis, then
z-axis.  Thus, if we write each rotation as @i{Rx}, @i{Ry}, and
@i{Rz}, the returned matrix is @i{RzRyRx}.
The default value of @var{order} is @code{xyz}.

The desrtuctive version modifies @var{m}.
@end defun

@defun matrix4f-decompose m
Matrix @var{m} is a composition of translation, rotation, shear and
scale.  Suppose transformation is applied in the reverse order.
This procedure decompose @var{m} into each individual transformation.

Returns five values.
@itemize @bullet
@item
A flag to indicate if @var{m} is non-singular.
@item
A translation vector @var{t}, in vector4f.  The first three elements
of @var{t} are for x, y, and z translations.
@item
A rotation matrix @var{r}, in matrix4f.
This is an orthogonal matrix represents rotation component.
@item
A shear vector @var{h}, in vector4f.  The first three elements
of @var{h} are for xy, xz and yz shear factors.
@item
A scale vector @var{s}, in vector4f.  The first three elements
of @var{s} are fof x, y, and z scale factors.
@end itemize

If @var{m} is singular, certain part of rotation matrix can't 
be recovered.   In such a case, @var{r} becomes also singular matrix.

If the original matrix has negative scale factor in any of 
x, y, or z scale, the decomposed scale factor will have all negative
components.  The signs of elements of @var{r} are adjusted accordingly.

Due to the precision errors,
you will see small values appear in shear component even @var{m} is
pure TRS matrix.
@end defun

@defun matrix4f-decompose! m t r h s
Linear update version of @code{matrix4f-decompose}.
The result vectors and matrices are stored in @var{t}, @var{r}, @var{h}
and @var{s}.  The return value is a boolean value indicates
@var{m} is non-singular or not.
@end defun

@defun matrix4f->translation m
Extract the translation component from the given TRS matrix @var{m}
and returns it as a @code{<vector4f>}.
@end defun

@defun matrix4f->translation! v m
Extract the translation component from the given TRS matrix @var{m}
and stores the result into a @code{<vector4f>} @var{v}.
Returns @var{v}.
@end defun

@defun matrix4f->rotation m
From given orthogonal matrix @var{m}, extracts and returns
and rotation axis and angle, as a vector4f and a real number.
@end defun

@defun matrix4f->rotation! v m
Same as above, except the storage of vector4f @var{v} is reused
to store the result axis.
@end defun

@c ----------------------------------------------------------------------
@node Quaternions,  , Matrices, Vectors and matrices
@section Quaternions

@deftp {Class} <quatf>
@clindex quatf
Quaternions.   Internally quaternions are represented as just
an array of four floats; the first three are the vector component
and the last is the scalar component.

Inherits @code{<sequence>} and @code{<collection>}.  When viewed
as sequence, it is just like a vector of four floats.
@end deftp

@defun quatf? obj
Returns true iff @var{obj} is a quaternion.
@end defun

@deftp {Reader syntax} @code{#,(quatf @var{x} @var{y} @var{z} @var{w})}
External representation of quaternion
@i{x}@b{i}+@i{y}@b{j}+@i{z}@b{k}+@i{w}.
@end deftp

@defun make-quatf &optional axis (angle 0)
Returns a new unit quaternion that represents a rotation
around vector @var{axis} by @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@var{Axis} must be a unit vector; if @var{axis} is anormalized,
the result is undefined.

If both @var{axis} and @var{angle} is omitted,
@code{#,(quatf 0 0 0 1)} is returned.
@end defun

@defun quatf x y z w
Returns a new quaternion whose elements are initialized by
@var{x}, @var{y}, @var{z}, @var{w}.
@end defun

@defun list->quatf l
@defunx quatf->list q
Converts between a list of four real numbers and a quaternion.
@end defun

@defun f32vector->quatf x &optional start
Returns a new quaternion whose elements are initialized by
the first four elements of f32vector @var{x}.
If @var{start} is given, the initial value is taken
starting from @var{start}-th index in @var{x}.
@end defun

@defun quatf->f32vector q
Returns a new f32vector whose contents is the same as a quaternion @var{q}.
@end defun

@defun quatf-copy q
Returns a fresh copy of a quaternion @var{q}.
@end defun

@defun quatf-copy! dstq srcq
Copies contents of a quaternion @var{srcq} to a quaternion @var{dstq}.
@end defun

@defun rotation->quatf! quat axis angle
Sets a quaternion @var{quat} so that it represents a rotation
around a unit vector @var{axis} by angle @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@end defun

@defun vectors->quatf v w
@defunx vectors->quatf! q v w
Given two unit vectors @var{v} and @var{w}, calculates and returns
a quaternion that represents a rotation from @var{v} to @var{w}.
The destructive version @code{vectors->quatf!} modifies @var{q}.
@end defun

@defun axes->quatf v1 v2 w1 w2
@defunx axes->quatf! q v1 v2 w1 w2
The arguments must be all unit vectors,
@var{v1} and @var{v2} must be perpendicular, 
and also @var{w1} and @var{w2} must be perpendicular.

Calculates and returns a quaternion that represents a rotation
which transforms @var{v1} to @var{w1}, and @var{v2} to @var{w2},
respectively.  The destructive version stores the result
into @var{q}.
@end defun

@defun quatf-add p q
@defunx quatf-add! p q
@defunx quatf-sub p q
@defunx quatf-sub! p q
Addition and subtraction of quaternions.  The destructive version
modifies the first argument.
@end defun

@defun quatf-scale q s
@defunx quatf-scale! q s
Multiplies a quaternion @var{q} by a scalar value @var{s}.
The destructive version modifies @var{q}.
@end defun

@defun quatf-mul p q
@defunx quatf-mul! p q
Multiply two quaternions @var{p} and @var{q}.
The destructive version modifies @var{p} as well.
@end defun

@defun quatf-conjugate p
@defunx quatf-conjugate! q p
Returns a conjugate of a quaternion @var{p}.
The destructive version modifies @var{q} as well.
@end defun

@defun quatf-transform q p
Transforms a vector or a point @var{p} by quaternion @var{q},
that is, returns @var{qpq*}, where @var{q*} is a conjugate of @var{q}.

This procedure assumes @var{q} is normalized.

@var{P} can be a vector4f, a point4f or a f32vector
(only first three elements are used).
Returns the same type of object as @var{p}.
@end defun

@defun quatf-norm q
Returns norm of @var{q}.
@end defun

@defun quatf-normalize q
@defunx quatf-normalize! q
Returns normalized quaternion of @var{q}.
The destructive version modifies @var{q}.
@end defun

@defun quatf->matrix4f q
@defunx quatf->matrix4f! m q
Returns a matrix that represents a rotation specified by a unit
quaternion @var{q}.
The behavior is undefined if @var{q} is not normalized.
The destructive version modifies @var{m}.
@end defun

@defun matrix4f->quatf m
@defunx matrix4f->quatf! q m
Extracts the rotation component of a matrix @var{m} and
returns a quaterion that represents the rotation.
@code{Matrix4f->quatf!} also uses @var{q} as the storage
to store the result.
@end defun

@defun quatf-slerp p q t
@defunx quatf-slerp! r p q t
Returns a quaternion that interpolates between two
unit quaternions @var{p} and @var{q}, by a scalar value @var{t}.
The destructive version modifies @var{r}.
@end defun

@c ======================================================================
@node Simple utilities, Indices, Vectors and matrices, Top
@chapter Simple utilities

This chapter covers @code{gl.simple.*} modules.  They are
provided for the convenience of those who wants quick experiment
with Gauche-gl alone, without a hassle to install a bunch of
other modules.  Their features are pretty limited, but you
may find them handy when you need to hack up some throwaway
script that need to show some graphics on the screen.

@menu
* Simple image handling::       
* Simple viewer::               
@end menu

@node Simple image handling, Simple viewer, Simple utilities, Simple utilities
@section Simple image handling

@deftp {Module} gl.simple.image
@mdindex gl.simple.image
OpenGL doesn't provide any means of reading/writing image data, and
it should be covered by other Gauche extensions.  However,
it is sometimes handy to have simple means to handle external
image data, so that you can do some experiment with Gauche-gl alone.

This module provides a minimal support to handle external image
data, so that one can do some experiment in Gauche-gl alone.

The functionality might be extended over time, but this is never
intended to be a full featured image library.  A separate Gauche
extension should be a better place to have it.
@end deftp

Currently, only reading from 8bit SGI image file is supported.
It is written in pure Scheme, so don't expect the performance.

@defun read-sgi-image filename
@defunx read-sgi-image-from-port port
Reads an image data in SGI format from the named file or the input port,
respectively.

Only 8bit-per-channel, direct color mode is supported.

Returns four values: the image's width in pixels, its height in pixels,
number of channels (e.g. 1 for grayscale, 3 for RGB, 4 for RGBA),
and the image data in u8vector.   The pixel data is packed, i.e. there's
no padding between each pixel nor each scanline.

Warning: be careful to call this function interactively.  The
image data vector is usually huge, and you have to wait long
for the REPL to display the entire result.
@end defun

@node Simple viewer,  , Simple image handling, Simple utilities
@section Simple viewer

@deftp {Module} gl.simple.viewer
@mdindex gl.simple.viewer
This module packages common operations to allow users to
view 3D objects, controlling the camera by the mouse,
and have some interactions with the keyboard.

A typical way of using the viewer is like the following:

@example
(use gl)
(use gl.glut)
(use gl.simple.viewer)

(define (main args)
  (glut-init args)
  (simple-viewer-display <your-display-thunk>)
  (simple-viewer-set-key! <key> <handler> ...)
  (simple-viewer-window <name> :title <title> ...)
  (simple-viewer-run) ; loop forever.  type ESC to exit.
  0)
@end example

The viewer handles mouse drag (to move the camera),
and also draws reference grid and axes by default for
your convenience.  You have to provide a thunk, which
must draw your 3D object.

For the keyboard events, you can use a convenient API
to associate handler to the key (character for normal keys,
and constants like @code{GL_LEFT_ARROW} for special keys).

The reshape event is handled implicitly, though you can
override it.

If you call @code{simple-viewer-run}, it enters the event
loop and never returns.  If you wish to keep REPL and/or
other parts of your application run concurrently, 
the convenient way is to run @code{simple-viewer-run}
in a separate thread.

@example
(use gauche.threads)

(define (run-viewer)
  (thread-start! (make-thread simple-viewer-run #f)))
@end example

See also the code under @file{examples/simple} directory
of the source tree for more examples.
@end deftp

@defun simple-viewer-window name &key title mode parent width height x y
Creates a new GL window with @var{name}, which must be a symbol
to identify the window later in the simple viewer framework.
The window won't be shown until @code{simple-viewer-run} is called.

Each window 
@end defun


@defun simple-viewer-display &optional display-thunk
Gets/sets the display thunk, which is called every time
the GL window is redrawn.  You can change the display thunk
any time, even while the viewer thread is running.

If no argument is given, returns the current display thunk.
It can be @code{#f} if no display thunk is set.

When the display thunk is called, the matrix mode is 
@code{MODELVIEW} and the camera transformation is already applied.
The grid and axes are also drawn, unless you've customized them.

In the display thunk you can just write your model in the
world coordinate system.  It is guaranteed that
the current color is white and line width is 1.0, but
the states of other GL contexts are undefined,
so you have to set them explicitly.
@end defun

@defun simple-viewer-reshape &optional reshape-proc
Gets/sets the reshape procedure which is called every
time the GL window configuration is changed.  (It is
also called when the GL window is shown first time.)
You can change the reshape procedure any time,
even while the viewer thread is running.

If no argument is given, returns the current reshape proc.

A reshape procedure is called with two arguments,
the width and the height (in pixels) of the new GL
window configuration.  By default, @code{gl.simple.viewer}
sets a procedure that changes viewport and
projection matrix apopropriately; you need to change
it only if you want a different behavior.
@end defun

@defun simple-viewer-grid &optional grid-proc
@defunx simple-viewer-axis &optional axis-proc
Gets/sets a procedure to draw a grid and axes.  
You can change these procedures
any time, even while the viewer thread is running.

The @var{grid-proc} and @var{axis-proc} are called with no arguments
every time the GL window is redrawn, before the display thunk
is invoked.
The matrix mode is @code{MODELVIEW}, the camera transformation
is already applied, and lighting is disabled.

The default grid proc draws 10x10 grid
on X-Z plane centered at the origin.  The default axis proc
draws a red line from origin to +X, a green line from origin to +Y,
and a blue line from origin to +Z.  

You can pass @code{#f} to disable grid and/or axis display.

If no argument is given, returns the current grid/axis proc,
respectively.
@end defun

@defun simple-viewer-set-key! key handler @dots{}
Even number of arguments must be given; the first of
every two specifies the key, and the next one
specifies the action when the key is pressed.
@end defun





@c ======================================================================
@node Indices,  , Simple utilities, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Function and Syntax Index, Module Index, Indices, Indices
@appendixsec Function and Syntax Index
@c NODE 手続きと構文索引
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Indices
@appendixsec Module Index
@c NODE モジュール索引
@printindex md

@node Class Index, Variable Index, Module Index, Indices
@appendixsec Class Index
@c NODE クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Indices
@appendixsec Variable Index
@c NODE 変数索引
@printindex vr


@contents
@bye

@c Local variables:
@c outline-regexp: "@chap\\|@unnu\\|@\\(sub\\)*section"
@c end:

