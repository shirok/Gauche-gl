\input texinfo  @c -*-texinfo-*-
@comment %**start of header
@c EN
@setfilename gauche-gl-refe.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference: (gauche-gl-refe.info).	Gauche OpenGL binding
@end direntry
@c JP
@setfilename gauche-gl-refj.info
@settitle Gauche-gl : OpenGL binding for Gauche
@dircategory The Algorithmic Language Scheme
@direntry
* Gauche-gl Reference (ja): (gauche-gl-refj.info).	Gauche OpenGL binding
@end direntry
@c COMMON
@comment %**end of header

@c $Id: gauche-gl-ref.texi,v 1.14 2005-06-05 11:53:40 shirok Exp $

@c module and class index
@defcodeindex md
@defcodeindex cl

@iftex
@finalout
@parskip 4pt plus 1pt
@end iftex

@titlepage
@c EN
@title Gauche-gl : OpenGL binding for Gauche
@c JP
@title Gauche-gl : OpenGL binding for Gauche
@c COMMON
@subtitle version @VERSION@
@author Shiro Kawai (shiro@@acm.org)

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2003 Shiro Kawai (shiro@@acm.org)

@end titlepage

@node Top, Introduction, (dir), (dir)

@ifnottex
This is a reference manual of Gauche-gl, an OpenGL binding for the
Gauche Scheme implementation.
This manual is for version @VERSION@.
@end ifnottex

@c ======================================================================
@menu
* Introduction::                
* Installation::                
* Getting Started::             
* OpenGL API::                  
* GLU API::                     
* GLUT API::                    
* Vectors and matrices::        
* Indices::                     
@end menu

@node Introduction, Installation, Top, Top
@chapter Introduction
@c NODE はじめに

Gauche-gl is an extension module of Gauche Scheme implementation.
It provides the following modules:

@table @code
@item gl
The module that provides bindings to OpenGL API.
It covers almost all functions in OpenGL 1.0 through 1.5 and 2.0,
registered vendor extensions, and most functions in GLU.
The functions are described in @ref{OpenGL API} and @ref{GLU API}.
@item gl.glut
The module that provides bindings to most functions in GLUT.
The functions are described in @ref{GLUT API}.
@item gl.math3d
The module that provides vector and matrix calculations
optimized for 3D homogeneous coordinates.
The vector and matrix objects here can be directly passed to
Gauche-gl functions.
The functions are descrbied in @ref{Vectors and matrices}.
@end table

@c ======================================================================
@node Installation, Getting Started, Introduction, Top
@chapter Installation

Installing Gauche-gl is usually straightforward on Unix variants.

You have to have the following programs installed on your machine.
@itemize @bullet
@item
Gauche 0.8.4 or later
@item
OpenGL 1.1 equivalent library; the auther checked with Mesa 3.4
and NVidia's GLX driver.
@item
GLUT 3.7 or later.
@end itemize

The standard way to compile and install Gauche-gl is as follows:
@example
% gzcat Gauche-gl-@VERSION@.tgz | tar xf -
% cd Gauche-gl-@VERSION@
% ./configure
% make
% make test
% make install
@end example

The confiugre script figures out the location Gauche is installed,
and install Gauche-gl in the same place.

If you have GLUT installed in non-standard place, you have to
tell the configure script where it is.
@example
% ./configure --with-glut=DIR
@end example

It is reported that Mesa in FreeBSD ports is compiled with pthreads
enabled, and Gauche-gl can't be linked unless Gauche itself is
compiled with pthreads.  The configure script of Gauche prints
warning if you specify pthreads, but it is safe as far as you
don't call make-thread in your program.

@c ======================================================================
@node Getting Started, OpenGL API, Installation, Top
@chapter Getting Started

@menu
* GL calls in Scheme::          
* Advanced GL features::        
* Using GLUT::                  
* Performance tips::            
@end menu

@node GL calls in Scheme, Advanced GL features, Getting Started, Getting Started
@section GL calls in Scheme

I assume you have basic knowledge of OpenGL API.
Gauche-gl maps OpenGL calls to Scheme procedures
pretty straightforwardly.  For example, the very first
example of "OpenGL Programming Guide", the pseudo code
of OpenGL application, can be written in Gauche-gl like
this:

@example
(use gl)

(define (main args)
  (@i{initialize-a-window-please})

  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color 1.0 1.0 1.0)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  (gl-begin* GL_POLYGON
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
    )
  (gl-flush)
  (@i{update-the-window-and-check-for-events})
  0)
@end example

Note that @i{initialize-a-window-please} and
@i{update-the-window-and-check-for-events} are function calls
dependent on the windowing system.  Gauche-gl comes with GLUT
binding and you can use it to do basic stuff.  In the separate
package Gauche-gtk, a binding to GtkGLExt is provided, which allows
you to do GL rendering inside Gtk widgets.

For the time being, let's focus on the pure GL part.

The mapping of GL call name is straightforward.
The mixed case names in OpenGL C API is expanded to hyphenated name,
e.g. @code{glClearColor} @result{} @code{gl-clear-color}.
OpenGL enums are mapped as is, e.g. 
@code{GL_POLYGON}.  (Note that Gauche is case-sensitive by default.
Also note the underscore, not hyphen, in constants).

A few convenience macros, such as @code{gl-begin*}, is defined.
There are straight bindings of @code{gl-begin} and @code{gl-end},
so you can write the drawing part in the same way as in C:
@example
  (gl-begin GL_POLYGON)
    (gl-vertex 0.25 0.25 0.0)
    (gl-vertex 0.75 0.25 0.0)
    (gl-vertex 0.75 0.75 0.0)
    (gl-vertex 0.25 0.75 0.0)
  (gl-end)
@end example

Actually @code{gl-begin*} macro expands into the above calls.
It's a matter of taste, but the macro version guarantees
begin and end match, and the syntax-aware editor can indent 
internal calls accordingly.

You might have noticed that the type suffix in C API
is not in Gauche binding.  The Scheme function figures out the
type of passed arguments and calls appropriate C API.
SRFI-4 uniform numeric vectors are used to represent
arrays of numbers.

@example
  (gl-vertex 1.0 2.0 3.0)    @result{} glVertex3d
  (gl-vertex '#f32(1.0 2.0)) @result{} glVertex2fv
  (gl-vertex '#s32(3 2 5))   @result{} glVertex3iv
@end example

Generally, passing uniform vectors is much more efficient than
giving individual numbers, for the former can eliminate
the cost of type checking and unboxing.

Some GL calls can also take @code{gl.math3d} primitive objects
such as @code{vector4f}, @code{point4f} or @code{matrix4f}
(@xref{Vectors and matrices}).   For example, you can pass
@code{point4f} object to @code{gl-vertex}, @code{vector4f} to
@code{gl-normal}, and @code{matrix4f} to @code{gl-mult-matrix}.
They are efficient since calculations on those types are
defined natively in @code{gl.math3d}, and passing it to GL call
doesn't cost unboxing.

@node Advanced GL features, Using GLUT, GL calls in Scheme, Getting Started
@section Advanced GL features

Although Gauche-gl supports up to OpenGL 2.0, all functionalities
may not be available on the target machine's driver/hardware.
The application needs to check the availability of the extension
and/or GL version before using the features that are only supported
by the extension/version.

Gauche-gl provides a couple of utility procedures to check the
feature sets at runtime.
For example, you can switch behavior depending on OpenGL 1.3 feature
availability:

@example
(if (gl-version>=? "1.3")
  (code-using-features-available-in-OpenGL-1.3-and-later ...)
  (alternative-code ...))
@end example

Or you can check the availability of extensions:

@example
(unless (gl-extension-supported? 'GL_ARB_shader_objects
                                 'GL_ARB_fragment_shader
                                 'GL_ARB_vertex_shader
                                 'GL_ARB_shading_language_100)
   (error "OpenGL Shading Language extensions not available"))
@end example

See @ref{GL feature checking} for the details.

If the client program calls a GL API that are not supported on
the platform, an error is signalled.


@node Using GLUT, Performance tips, Advanced GL features, Getting Started
@section Using GLUT

In order to make a runnable script, you need to use some
windowing system interface.  GLUT binding provides a simple
way for it.

Here is a complete runnable Scheme script, ported from
Example 1-2 in "OpenGL Programming Guide":

@example
(use gl)
(use gl.glut)

(define (disp)
  (gl-clear GL_COLOR_BUFFER_BIT)
  (gl-color '#f32(1.0 1.0 1.0))
  (gl-begin* GL_POLYGON
    (gl-vertex '#f32(0.25 0.25 0.0))
    (gl-vertex '#f32(0.75 0.25 0.0))
    (gl-vertex '#f32(0.75 0.75 0.0))
    (gl-vertex '#f32(0.25 0.75 0.0))
    )
  (gl-flush)
  )

(define (init)
  (gl-clear-color 0.0 0.0 0.0 0.0)
  (gl-matrix-mode GL_PROJECTION)
  (gl-load-identity)
  (gl-ortho 0.0 1.0 0.0 1.0 -1.0 1.0)
  )

(define (keyboard key x y)
  (cond
   ((= key 27) (exit 0))
   ))

(define (main args)
  (glut-init args)
  (glut-init-display-mode (logior GLUT_SINGLE GLUT_RGB))
  (glut-init-window-size 250 250)
  (glut-init-window-position 100 100)
  (glut-create-window "hello")
  (init)
  (glut-display-func disp)
  (glut-keyboard-func keyboard)
  (glut-main-loop)
  0)
@end example

The @code{(use gl.glut)} form loads GLUT binding.
The name mapping is the same as GL's: mixed case names to 
hyphenated names.

In order to handle various events, you can pass a closure
to @code{glut-display-func} etc.  In the keyboard and mouse
event callback, all arguments are integers.

There are more examples under the @file{examples/} directory
which uses GLUT.

@node Performance tips,  , Using GLUT, Getting Started
@section Performance tips

If you want to display millions of polygons in 30 fps, 
Gauche-gl is not for you.   Consider using implementations
that compiles into native code.   The purpose of Gauche-gl
is to provide reasonable performance for interactive development
and experiment.

However, if you know some tips, actually you can go quite far,
especially with recent processors and graphics chips.

@table @emph
@item Avoid alocation within the inner loop.
The functional (non-destructive) operations tend to return 
newly-allocated objects.
Use linear-update (destructive) versions instead,
such as @code{matrix-mul!}, @code{u8vector-add!}, etc,
whenever possible.
Pre-allocating temporary vectors is also effective.

@item Reduce the number of calls within the inner loop.
Vertex arrays are much better than calling @code{gl-vertex}
over and over.   Also consider using display lists if
you're displaying rigid objects.

@item Keep numbers within a uniform vector.
Every time you take a number out of a uniform vector
(or @code{<vector4f>} etc.), Gauche has to wrap the
number by a tag (boxing).  Also when you store a number
into a uniform vector, Gauche has to check the type
of the object, then strip a tag (unboxing).
Those are all overhead you wouldn't have if
you operate directly on uniform vectors (or @code{<vector4f>} etc).

@item Write extensions to accelerate.
If the above strategies are not enough, consider writing
computation-intensive part in C as an extension.
The easier way is to make C routines operate on uniform vectors,
which is essentially a pointer to an array of numbers from C,
and let Scheme handle higher-level data structures.
(It could be viewed like relations between a coprocessor and
a processor; the former does simple, iterative calculations
fast, and the latter handles complicated logic).
@end table

@c ======================================================================
@node OpenGL API, GLU API, Getting Started, Top
@chapter OpenGL API

In this chapter we list a GL and GLU procedures accessible from
Gauche-gl, with brief descriptions to help programmers
to remind what the functions are.  We don't intend to make
this an OpenGL reference, though; you should look at the OpenGL book
for the details of what each API do.

@menu
* GL data types::               
* GL feature checking::         
* Drawing functions::           
* GL state control::            
* GL states::                   
* Depth buffer and accumulation buffer::  
* Transformation::              
* Display lists::               
* Vertex arrays::               
* Lighting::                    
* Raster functions::            
* Stenciling::                  
* Texture mapping::             
* Fog::                         
* Selection and feedback::      
* Color operations::            
@end menu

@node GL data types, GL feature checking, OpenGL API, OpenGL API
@section GL data types

GL doesn't define many data structures: some scalar primitives (e.g.
@code{GLint}) and arrays of them.

For scalar values, Gauche-gl has natural mappings:
@table @code
@item GLboolean
Scheme booleans.
@item GLbyte, GLubyte, GLshort, GLushort, GLint, GLuint, GLenum, GLbitfield
Scheme exact integers.
@item GLfloat, GLdouble, GLclampf, GLclampd
Scheme real numbers.
@end table


For arrays, Gauche-gl uses uniform (srfi-4) vector whenever possible.
For float arrays, however, Gauche-gl allows more structured types,
such as points or matrices, when they are relevant.  Such types are provided
in @code{gl.math3d} module (see @ref{Vectors and matrices}),
which also provides common arithmetics between those types.
Another exception is an array of GLboolean---it doesn't have corresponding
uniform vector representation.  Gauche-gl defines a new type,
@code{<gl-boolean-vector>}, to represent an array of GLboolean.
See below for operations provided on it.

@table @code
@item GLbyte[]
@code{<s8vector>}
@item GLubyte[]
@code{<u8vector>}
@item GLshort[]
@code{<s16vector>}
@item GLushort[]
@code{<u16vector>}
@item GLint[]
@code{<s32vector>}
@item GLuint[]
@code{<u32vector>}
@item GLfloat[], GLclampf[]
@code{<f32vector>}, @code{<point4f>}, @code{<vector-4f>},
@code{<point4f-array>}, @code{<vector4f-array>},
@code{<matrix4f>}, @code{<quatf>}.
@item GLdouble[], GLclampd[]
@code{<f64vector>}
@item GLboolean[]
@code{<gl-boolean-vector>}
@end table

@subheading GL boolean vectors

@deftp {Class} <gl-boolean-vector>
@end deftp

@defun make-gl-boolean-vector size &optional init
@end defun

@defun gl-boolean-vector bool @dots{}
@end defun

@defun gl-boolean-vector? obj
@end defun

@defun gl-boolean-vector-length v
@end defun

@defun gl-boolean-vector-fill! v bool
@end defun

@defun list->gl-boolean-vector bools
@end defun

@defun gl-boolean-vector-ref v k &optional fallback
@end defun

@defun gl-boolean-vector-set! v k bool
@end defun

@defun gl-boolean-vector-copy v
@end defun

@deftp {Reader syntax} #,(<gl-boolean-vector> bool @dots{})
@end deftp


@node GL feature checking, Drawing functions, GL data types, OpenGL API
@section GL feature checking

If you want to use a feature that are in OpenGL 1.2 or later, or
in a GL extension, you have to check its availability before
actually calling the API function.  You can use the following
utility procedures.

Note that those functions may return @code{#f} if the connection
to the display subsystem isn't established yet.  Usually you have
to initialize and open an window before checking the features.

@defun gl-extension-available? extension-name @dots{}
Returns @code{#t} if GL extensions listed in @var{extension-name} @dots{}
are all available.  @var{Extension-name} can be a symbol or
a string (e.g. @code{GL_ARB_multisample}).
@end defun

@defun gl-version<? version
@defunx gl-version<=? version
@defunx gl-version>? version
@defunx gl-version>=? version
@defunx gl-version=? version
Returns @code{#t} if the runtime OpenGL version is less than,
less thanor equal to, greater than, greater than or equal to,
and equal to, the given @var{version}, respectively.

Give @var{version} in a string, e.g. @code{"1.3"}.
@end defun

@node Drawing functions, GL state control, GL feature checking, OpenGL API
@section Drawing functions

@defmac gl-begin* mode gl-commands @dots{}
@vrindex GL_POINTS
@vrindex GL_LINES
@vrindex GL_LINE_STRIP
@vrindex GL_LINE_LOOP
@vrindex GL_TRIANGLES
@vrindex GL_TRIANGLE_STRIP
@vrindex GL_TRIANGLE_FAN
@vrindex GL_QUADS
@vrindex GL_QUAD_STRIP
@vrindex GL_POLYGON

Executes @var{gl-commands} between @code{(gl-begin @var{mode})} and
@code{(gl-end)}.  @var{Mode} can be one of the following constants.

@table @code
@item GL_POINTS
Individual points.
@item GL_LINES
Pairs of vertices interpreted as individual line segments.
@item GL_LINE_STRIP
Series of connected line segments.
@item GL_LINE_LOOP
Same as above, with a segment added between last and first vertices.
@item GL_TRIANGLES
Triples of vertices interpreted as triangles.
@item GL_TRIANGLE_STRIP
Linked trip of triangles.
@item GL_TRIANGLE_FAN
Linked fan of triangles.
@item GL_QUADS
Quadruples of vertices interpreted as four-sided polygons.
@item GL_QUAD_STRIP
Linked strip of quadrilaterals.
@item GL_POLYGON
Boundary of a simple, convex polygon.
@end table

@end defmac

@defun gl-begin mode
@defunx gl-end
Corresponds to @code{glBegin} and @code{glEnd}.
Use of @code{gl-begin*} macro is recommended, though.
@end defun

@defun gl-clear-color r g b a
Sets the current clearing color.
Each color value sould be a real number, and is clamped to
@code{[0.0,1.0]}.
@end defun

@defun gl-clear mask
Clears the specified buffer.   @var{Mask} is a logical-or of
the following constants.

@table @code
@item GL_COLOR_BUFFER_BIT
@item GL_DEPTH_BUFFER_BIT
@item GL_ACCUM_BUFFER_BIT
@item GL_STENCIL_BUFFER_BIT
@end table

@end defun

@defun gl-flush
Flush the GL command buffer.
@end defun

@defun gl-finish
Make sure all previously issued GL commands are completed.
@end defun

@defun gl-rect point1 point2
@defunx gl-rect x1 y1 x2 y2
Draws a rectangle.  In the first form,
@var{point1} and @var{point2} can be either
@code{<point4f>}, or f32, f64, s32, or s16vector of
length 2.   Types of both args should match.  
In the second form, all args should be a real numbers (@code{glRectd} is used).
@end defun

@defun gl-vertex point
@defunx gl-vertex x y &optional z w
Specify vertices.  In the first form, @var{point} can be
either @code{<point4f>}, or f32, f64, s32 or s16vector
of length 2, 3 or 4.
In the second form, all args should be a real numbers.
@end defun

@defun gl-normal vector
@defunx gl-normal x y z
Sets vertex normal vector.  In the first form, @var{vector} can be
either @code{<vector4f>} (the fourth element is ignored),
or f32, f64, s32 ro s16vector of length 3.
In the second form, all args should be a real numbers.
@end defun

@defun gl-color color
@defunx gl-color r g b &optional a
Sets the current color.  In the first form, @var{color} can be
either f32, f64, u8, u16, u32, s8, s16, or s32vector of length 3 or 4.
In the second form, all args should be a real numbers.
@end defun

@defun gl-tex-coord coord
@defunx gl-tex-coord u v &optional s t
Sets the current texture coordinates.  In the first form,
@var{coord} can be either f32, f64, s32 or s16vector of length
1, 2, 3, or 4.  In the second form, all args should be a real numbers.
@end defun

@defun gl-raster-pos pos
@defunx gl-raster-pos x y &optional z w
Sets the current raster position.  In the first form,
@var{pos} can be eitehr f32, f64, s32 or s16vector.  In the
second form, all args should be a real numbers.
@end defun

@node GL state control, GL states, Drawing functions, OpenGL API
@section GL state control

@subsubheading Capabilities

@defun gl-enable cap
@defunx gl-disable cap
Turns on and off a capability @var{cap}.  Check out OpenGL reference
for the list of capabilities.
@end defun

@defun gl-is-enabled cap
Returns @code{#t} of @code{#f} depending on @var{cap} is enabled or not.
@end defun

@defun gl-enable-client-state array
@defunx gl-disable-client-state array
Enable/disable a client-side array (e.g. vertex array) specified by
@var{array}.   @var{Array} can be one of the following constants.

@table @code
@item GL_VERTEX_ARRAY
@item GL_COLOR_ARRAY
@item GL_INDEX_ARRAY
@item GL_NORMAL_ARRAY
@item GL_TEXTURE_COORD_ARRAY
@item GL_EDGE_FLAG_ARRAY
@end table

@end defun

@subsubheading State values

Gauche has two variations for each type of OpenGL @code{glGetTYPE} APIs;
nondestructive version and destructive versions.  Nondestructive versions
such as @code{gl-get-boolean} allocates and returns the vector of
appropriate type for the state.  For destructive versions such as
@code{gl-get-boolean!}, you need to pass a vector to be filled in.

The destructive version is non-allocating operation, so it is suitable
if you call it within the drawing loop.

If the state has a scalar value, the non-destructive version of
query function returns a scalar value, but you need to pass a 
(uniform) vector of length 1 for the destructive version.

@defun gl-state-vector-size state
[Gauche specific]
Returns the required size of the vector to retrieve GL state @var{state}.
It is useful to prepare the vector to pass to the destructive version
of @code{glGetTYPE} API.
@end defun

@defun gl-get-boolean state
@defunx gl-get-boolean! gl-boolean-vector state
Get (a) boolean state value(s).
@end defun

@defun gl-get-integer state
@defunx gl-get-integer! s32vector state
Get (an) integer state value(s).
@end defun

@defun gl-get-float state
@defunx gl-get-float! f32vector state
Get (a) single-precision floating-point state value(s).
@end defun

@defun gl-get-double state
@defunx gl-get-double! f64vector state
Get (a) double-precision floating-point state value(s).
@end defun

@subsubheading Push/pop attributes

@defun gl-push-attrib mask
@defunx gl-pop-attrib
Push/pop attributes indicated by @var{mask}.
Valid @var{mask} can be @code{logior} of the following bits
(GLL_ALL_ATTRIB_BITS is @code{logior} of all the bits).

@table @code
@item GL_ACCUM_BUFFER_BIT
@item GL_COLOR_BUFFER_BIT
@item GL_CURRENT_BIT
@item GL_DEPTH_BUFFER_BIT
@item GL_ENABLE_BIT
@item GL_EVAL_BIT
@item GL_FOG_BIT
@item GL_HINT_BIT
@item GL_LIGHTING_BIT
@item GL_LINE_BIT
@item GL_LIST_BIT
@item GL_PIXEL_MODE_BIT
@item GL_POINT_BIT
@item GL_POLYGON_BIT
@item GL_POLYGON_STIPPLE_BIT
@item GL_SCISSOR_BIT
@item GL_STENCIL_BUFFER_BIT
@item GL_TEXTURE_BIT
@item GL_TRANSFORM_BIT
@item GL_VIEWPORT_BIT
@item GL_ALL_ATTRIB_BITS
All of the above.
@end table
@end defun

@defun gl-push-client-attrib mask
@defunx gl-pop-client-attrib 
Push/pop client attributes.  Valid @var{mask} can be
@code{logior} of the following

@table @code
@item GL_CLIENT_PIXEL_STORE_BIT
@item GL_CLIENT_VERTEX_ARRAY_BIT
@item GL_ALL_CLIENT_ATTRIB_BITS
All of the above.
@end table
@end defun

@subsubheading Other queries

@defun gl-get-error
Returns the value of the error flag.  Returned an integer value.
Check out the OpenGL documentation for the possible error values.

This function resets the error flag to @code{GL_NO_ERROR}.
@end defun

@defun glu-error-string error-code
Returns a descriptive string for @var{error-code} returned by
@code{gl-get-error}.
@end defun

@defun gl-get-string name
Returns informative string about @var{name} of the GL library.
@var{Name} can be one of the following.

@table @code
@item GL_VENDOR
@item GL_RENDERER
@item GL_VERSION
@item GL_EXTENSIONS
@end table

To check a specific version or extension, you can also use
the utility procedure @code{gl-version>?} etc.  See
@ref{GL feature checking}.
@end defun

@defun glu-get-string name
Returns informative string about @var{name} of the GLU library.
@var{Name} can be one of the following.

@table @code
@item GLU_VERSION
@item GLU_EXTENSIONS
@end table
@end defun

@subsubheading Hints

@defun gl-hint target hint
Controls quality of @var{target} by @var{hint}.
@var{Target} can be one of the following:

@table @code
@item GL_POINT_SMOOTH_HINT
@item GL_LINE_SMOOTH_HINT
@item GL_POLYGON_SMOOTH_HINT
@item GL_FOG_HINT
@item GL_PERSPECTIVE_CORRECTION_HINT
@end table

And @var{hint} can be one of the following:
@table @code
@item GL_FASTEST
@item GL_NICEST
@item GL_DONT_CARE
@end table
@end defun


@node GL states, Depth buffer and accumulation buffer, GL state control, OpenGL API
@section GL states

@defun gl-point-size size
Sets the width in pixels for rendered points.
The possible range of @var{size} on the running GL implementation
can be obtained by passing either @code{GL_ALIASED_POINT_SIZE_RANGE} or
@code{GL_SMOOTH_POINT_SIZE_RANGE} to @code{gl-get-float}.
@end defun

@defun gl-line-width width
Sets the width in pixels for rendered lines.
The possible range of @var{width} on the running GL implementation
can be obtained by passing either @code{GL_ALIASED_LINE_WIDTH_RANGE} or
@code{GL_SMOOTH_LINE_WIDTH_RANGE} to @code{gl-get-float}.
@end defun

@defun gl-line-stipple factor pat
Sets the current stippling pattern for lines.
@code{pat} must be an exact integer, and its lower 16 bits are used
to specify the stipple pattern.  @var{Factor} is an integer factor
to specify how many pixels corresponds to one bit in @var{pat}.

You have to enable @var{GL_LINE_STIPPLE} to use face culling.
@end defun

@defun gl-polygon-mode face mode
Specifies the drawing mode for a polygon's front and back faces.
@var{Face} can be one of the followings:
@table @code
@item GL_FRONT_AND_BACK
@item GL_FRONT
@item GL_BACK
@end table

@var{Mode} can be one of the followings:
@table @code
@item GL_POINT
@item GL_LINE
@item GL_FILL
@end table
@end defun

@defun gl-front-face mode
Controls how OpenGL determine front face of a polygon
@var{Mode} can be one of the followings:
@table @code
@item GL_CCW
Front face is where ordered vertices appear in a counterclockwise orientation
(default).
@item GL_CW
Front face is where ordered vertices appear in a clockwise orientation.
@end table
@end defun

@defun gl-cull-face mode
Indicates which face of polygons should be culled.
@var{Mode} can be one of the followings:
@table @code
@item GL_FRONT
@item GL_BACK
@item GL_FRONT_AND_BACK
@end table

You have to enable @var{GL_CULL_FACE} to use face culling.
@end defun

@defun gl-polygon-stipple mask
Defines the current stipple pattern for filled polygons.
@var{Mask} has to be a u8vector of length 128, specifying a 32x32 
bitmap pattern.
You have to enable @var{GL_POLYGON_STIPPLE} to use this feature.
@end defun



@defun gl-clear-index c
@var{c} must be a real number.
@end defun

@defun gl-index-mask mask
@end defun

@defun gl-color-mask r g b a
@end defun

@defun gl-alpha-func func ref
@end defun

@defun gl-blend-func func factor
@end defun

@defun gl-logic-op opcode
@end defun

@defun gl-polygon-offset factor units
[GL1.1]
@end defun

@defun gl-edge-flag flag
Sets the edge flag of vertices.

@end defun

@defun gl-scissor x y width height
@end defun

@defun gl-clip-plane plane equation
@end defun

@defun gl-get-clip-plane plane
@end defun

@defun gl-draw-buffer mode
@end defun

@defun gl-read-buffer mode
@end defun

@node Depth buffer and accumulation buffer, Transformation, GL states, OpenGL API
@section Depth buffer and accumulation buffer

@defun gl-clear-depth depth
@end defun

@defun gl-depth-func func
@end defun

@defun gl-depth-mask flag
@end defun

@defun gl-depth-range nearv farv
@end defun

@defun gl-clear-accum r g b a
@end defun

@defun gl-accum op value
@end defun

@node Transformation, Display lists, Depth buffer and accumulation buffer, OpenGL API
@section Transformation

@defun gl-matrix-mode mode
@end defun

@defun gl-ortho left right bottom top nearv farv
@end defun

@defun gl-frustum left right bottom top nearv farv
@end defun

@defun gl-viewport x y width height
@end defun

@defun gl-push-matrix
@defunx gl-pop-matrix
@end defun

@defun gl-load-identity
@end defun

@defun gl-load-matrix mat
@end defun

@defun gl-mult-matrix mat
@end defun

@defun gl-rotate angle x y z
@end defun

@defun gl-scale x y z
@end defun

@defun gl-translate x y z
@end defun

@node Display lists, Vertex arrays, Transformation, OpenGL API
@section Display lists

@defun gl-is-list list-no
@end defun

@defun gl-delete-lists list-no-start range
@end defun

@defun gl-gen-lists range
@end defun

@defun gl-new-list list-no mode
@end defun

@defun gl-end-list
@end defun

@defun gl-call-list list-no
@end defun

@defun gl-call-lists n type lists
@end defun

@defun gl-list-base base
@end defun

@node Vertex arrays, Lighting, Display lists, OpenGL API
@section Vertex arrays

NOTE: it is caller's responsibility to guarantee the passed vector
has enough length.  GL doesn't have an interface to specify the boundary,
so Gauche can't detect an invalid length vector.

@defun gl-vertex-pointer size vec &optional stride offset
@end defun

@defun gl-normal-pointer vec &optional stride offset
@end defun

@defun gl-color-pointer size vec &optional stride offset
@end defun

@defun gl-index-pointer vec &optional stride offset
@end defun

@defun gl-tex-coord-pointer size vec &optional stride offset
@end defun

@defun gl-edge-flag-pointer vec &optional stride offset
@end defun

@defun gl-array-element ith
@end defun

@defun gl-draw-elements mode indices
@end defun

@defun gl-interleaved-arrays format vec &optional stride offset
@end defun

@node Lighting, Raster functions, Vertex arrays, OpenGL API
@section Lighting

@defun gl-shade-model mode
@end defun

@defun gl-light light pname param
@end defun

@defun gl-get-light light pname
@end defun

@defun gl-light-model pname param
@end defun

@defun gl-matrial face pname param
@end defun

@defun gl-get-material face pname
@end defun

@defun gl-color-material face mode
@end defun

@node Raster functions, Stenciling, Lighting, OpenGL API
@section Raster functions

@defun gl-pixel-zoom xfactor yfactor
@end defun

@defun gl-pixel-store pname param
@end defun

@defun gl-pixel-map map values
@end defun

@defun gl-get-pixel-map map &optional type
@defunx gl-get-pixel-map! map values
@end defun

@defun gl-bitmap width height xbo ybo xbi ybi bitmap
@end defun

@defun gl-read-pixels x y width height format type
@end defun

@defun gl-draw-pixels width height format type pixels
@end defun

@defun gl-copy-pixels x y width height type
@end defun

@node Stenciling, Texture mapping, Raster functions, OpenGL API
@section Stenciling

@defun gl-stencil-func func ref mask
@end defun

@defun gl-stencil-mask mask
@end defun

@defun gl-stencil-op func zfail zpass
@end defun

@defun gl-clear-stencil s
@end defun

@node Texture mapping, Fog, Stenciling, OpenGL API
@section Texture mapping

@defun gl-tex-gen coord pname param
@end defun

@defun gl-tex-env target pname param
@end defun

@defun gl-tex-parameter target pname param
@end defun

@defun gl-get-tex-parameter target pname
@end defun

@defun gl-tex-image-1d target level internalformat width border format type texels
@end defun

@defun gl-tex-image-2d target level internalformat width height border format type texels
@end defun

@defun gl-tex-image-3d target level internalformat width height depth border format type texels
[GL1.2]
@end defun


@defun gl-gen-textures size
@end defun

@defun gl-delete-textures names
@end defun

@defun gl-bind-texture target name
@end defun

@defun gl-prioritize-textures n names properties
@end defun

@defun gl-are-texture-resident n names
@end defun

@defun gl-is-texture name
@end defun

@defun gl-tex-sub-image-1d target level xoffset width format type texels
[GL1.1]
@end defun

@defun gl-tex-sub-image-2d target level xoffset yoffset width height format type texels
[GL1.1]
@end defun

@defun gl-tex-sub-image-3d target level xoffset yoffset zoffset width height depth format type texels
[GL1.2]
@end defun


@defun gl-copy-tex-image-1d target level internal-format x y width border
@end defun

@defun gl-copy-tex-image-2d target level internal-format x y width height border
@end defun

@defun gl-copy-tex-sub-image-1d target level xoffset x y width
[GL1.1]
@end defun

@defun gl-copy-tex-sub-image-2d target level xoffset yoffset x y width height
[GL1.1]
@end defun

@defun gl-copy-tex-sub-image-3d target level xoffset yoffset zoffset x y width height
[GL1.2]
@end defun

@node Fog, Selection and feedback, Texture mapping, OpenGL API
@section Fog

@defun gl-fog pname param
@end defun

@node Selection and feedback, Color operations, Fog, OpenGL API
@section Selection and feedback

@defun gl-feedback-buffer type buffer
@end defun

@defun gl-select-buffer buffer
@end defun

@defun gl-render-mode mode
@end defun

@defun gl-pass-through token
@end defun

@defun gl-init-names
@end defun

@defun gl-load-name name
@end defun

@defun gl-push-name name
@end defun

@defun gl-pop-name
@end defun

@node Color operations,  , Selection and feedback, OpenGL API
@section Color operations

@defun gl-color-table target internal-format width format type data
@end defun

@defun gl-color-sub-table target start count format type data
@end defun

@defun gl-color-table-parameter target pname param
@end defun

@defun gl-copy-color-sub-table target start x y width
@end defun

@defun gl-copy-color-table target internal-format x y width
@end defun

@defun gl-blend-equation mode
@end defun

@defun gl-blend-color red green blue alpha
@end defun

@defun gl-histogram target width internal-format sink
@end defun

@defun gl-reset-histogram target
@end defun

@defun gl-minmax target internal-format sink
@end defun

@defun gl-reset-minmax target
@end defun



@c ======================================================================
@node GLU API, GLUT API, OpenGL API, Top
@chapter GLU API

@menu
* Projection::                  
* Quadrics::                    
* Nurbs::                       
* Polygon tesselation::         
* GLU miscellaneous utilities::  
@end menu

@node Projection, Quadrics, GLU API, GLU API
@section Projection

@defun glu-look-at eyex eyey eyez ctrx ctry ctrz upx upy upz
@end defun

@defun glu-ortho-2d left right bottom top
@end defun

@defun glu-perspective fovy aspect znear zfar
@end defun

@defun glu-pick-matrix x y w h vp
@end defun

@defun glu-project objx objy objz model-mat proj-mat vp
@end defun

@defun glu-un-project winx winy winz model-mat proj-mat vp
@end defun

@defun glu-project! win obj model-mat proj-mat vp
@end defun

@defun glu-un-project! obj win model-map proj-mat vp
@end defun

@node Quadrics, Nurbs, Projection, GLU API
@section Quadrics

@deftp {Class} <glu-quadric>
@end deftp

@defun glu-quadric-draw-style quad style

@defvr {Constant} GLU_POINT
@defvrx {Constant} GLU_LINE
@defvrx {Constant} GLU_FILL
@defvrx {Constant} GLU_SILHUETTE
@end defvr

@end defun

@defun glu-quadric-orientation quad orientation

@defvr {Constant} GLU_OUTSIDE
@defvrx {Constant} GLU_INSIDE
@end defvr

@end defun

@defun glu-quadric-normals quad normals

@defvr {Constant} GLU_SMOOTH
@defvrx {Constant} GLU_FLAT
@defvrx {Constant} GLU_NONE
@end defvr

@end defun

@defun glu-quadric-texture quad texcoords
@end defun

@defun glu-cylinder quad base-radius top-radius height slices stacks
@end defun

@defun glu-sphere quad radius slices stacks
@end defun

@defun glu-disk quad inner-radius outer-radius slices loops
@end defun

@defun glu-partial-disk quad inner-radius outer-radius slices loops start-angle sweep-angle
@end defun

@node Nurbs, Polygon tesselation, Quadrics, GLU API
@section Nurbs

@deftp {Class} <glu-nurbs>
@end deftp

@defun glu-load-sampling-matrices nurbs model-matrix proj-matrix viewport
@end defun

@defun glu-nurbs-property nurbs property value
@end defun

@defun glu-get-nurbs-property nurbs property
@end defun

@defun glu-begin-curve nurbs
@end defun

@defun glu-end-curve nurbs
@end defun

@defun glu-nurbs-curve nurbs knot stride ctlarray order type
@end defun

@defun glu-begin-surface nurbs
@end defun

@defun glu-end-surface nurbs
@end defun


@node Polygon tesselation, GLU miscellaneous utilities, Nurbs, GLU API
@section Polygon tesselation

@deftp {Class} <glu-tesselator>
@end deftp


@node GLU miscellaneous utilities,  , Polygon tesselation, GLU API
@section Miscellaneous utilities

@defun glu-error-string code
@end defun

@defun glu-get-string name
[GLU1.1]
@end defun




@c ======================================================================
@node GLUT API, Vectors and matrices, GLU API, Top
@chapter GLUT API

@c ----------------------------------------------------------------------
@menu
* GLUT window manipulation::    
* GLUT overlay::                
* GLUT menu API::               
* GLUT callbacks::              
* GLUT colormap::               
* GLUT state retrieval::        
* GLUT font::                   
* GLUT pre-built models::       
@end menu

@node GLUT window manipulation, GLUT overlay, GLUT API, GLUT API
@section GLUT window manipulation

@defun glut-init args
@end defun

@defun glut-init-display-mode mode
@end defun

@defvr {Constant} GLUT_RGB
@defvrx {Constant} GLUT_RGBA
@defvrx {Constant} GLUT_INDEX
@defvrx {Constant} GLUT_SINGLE
@defvrx {Constant} GLUT_DOUBLE
@defvrx {Constant} GLUT_ACCUM
@defvrx {Constant} GLUT_ALPHA
@defvrx {Constant} GLUT_DEPTH
@defvrx {Constant} GLUT_STENCIL
@defvrx {Constant} GLUT_MULTISAMPLE
@defvrx {Constant} GLUT_STEREO
@defvrx {Constant} GLUT_LUMINANCE
@end defvr

@defun glut-init-display-string string
@end defun

@defun glut-init-window-size width height
@end defun

@defun glut-init-window-position x y
@end defun

@defun glut-main-loop
@end defun

@defun glut-create-widnow name
@end defun

@defun glut-create-sub-window win x y width height
@end defun

@defun glut-destroy-window win
@end defun

@defun glut-post-redisplay
@end defun

@defun glut-post-window-redisplay win
@end defun

@defun glut-swap-buffers
@end defun

@defun glut-get-window
@end defun

@defun glut-set-window win
@end defun

@defun glut-set-window-title title
@end defun

@defun glut-set-icon-title title
@end defun

@defun glut-position-window x y
@end defun

@defun glut-reshape-window width height
@end defun

@defun glut-push-window
@defunx glut-pop-window
@end defun

@defun glut-iconify-window
@end defun

@defun glut-show-window
@defunx glut-hide-window
@end defun

@defun glut-full-screen
@end defun

@defun glut-set-cursor cursor
@end defun

@defvr {Constant} GLUT_CURSOR_RIGHT_ARROW
@defvrx {Constant} GLUT_CURSOR_LEFT_ARROW
@defvrx {Constant} GLUT_CURSOR_INFO
@defvrx {Constant} GLUT_CURSOR_DESTROY
@defvrx {Constant} GLUT_CURSOR_HELP
@defvrx {Constant} GLUT_CURSOR_CYCLE
@defvrx {Constant} GLUT_CURSOR_SPRAY
@defvrx {Constant} GLUT_CURSOR_WAIT
@defvrx {Constant} GLUT_CURSOR_TEXT
@defvrx {Constant} GLUT_CURSOR_CROSSHAIR
@defvrx {Constant} GLUT_CURSOR_UP_DOWN
@defvrx {Constant} GLUT_CURSOR_LEFT_RIGHT
@defvrx {Constant} GLUT_CURSOR_TOP_SIDE
@defvrx {Constant} GLUT_CURSOR_BOTTOM_SIDE
@defvrx {Constant} GLUT_CURSOR_LEFT_SIDE
@defvrx {Constant} GLUT_CURSOR_RIGHT_SIDE
@defvrx {Constant} GLUT_CURSOR_TOP_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_TOP_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_RIGHT_CORNER
@defvrx {Constant} GLUT_CURSOR_BOTTOM_LEFT_CORNER
@defvrx {Constant} GLUT_CURSOR_INHERIT
@defvrx {Constant} GLUT_CURSOR_NONE
@defvrx {Constant} GLUT_CURSOR_FULL_CROSSHAIR
@end defvr


@defun glut-warp-pointer x y
@end defun

@c ----------------------------------------------------------------------
@node GLUT overlay, GLUT menu API, GLUT window manipulation, GLUT API
@section GLUT overlay

@defun glut-establish-overlay
@end defun

@defun glut-remove-overlay
@end defun

@defun glut-use-layer layer
@end defun

@defun glut-post-overlay-redisplay
@end defun

@defun glut-post-window-overlay-redisplay win
@end defun

@defun glut-show-overlay
@end defun

@defun glut-hide-overlay
@end defun

@c ----------------------------------------------------------------------
@node GLUT menu API, GLUT callbacks, GLUT overlay, GLUT API
@section GLUT menu API

@defun glut-create-menu callback
@end defun

@defun glut-destroy-menu menu
@end defun

@defun glut-get-emnu
@end defun

@defun glut-set-menu menu
@end defun

@defun glut-add-menu-entry label value
@end defun

@defun glut-add-sub-menu label submenu
@end defun

@defun glut-change-to-menu-entry item label value
@end defun

@defun glut-change-to-sub-menu item label submenu
@end defun

@defun glut-remove-menu-item item
@end defun

@defun gult-attach-menu button
@end defun

@defun glut-detach-menu button
@end defun

@c ----------------------------------------------------------------------
@node GLUT callbacks, GLUT colormap, GLUT menu API, GLUT API
@section GLUT callbacks

@defun glut-display-func fn
@end defun

@defun glut-reshape-func fn
@end defun

@defun glut-keyboard-func fn
@end defun

@defvr {Constant} GLUT_KEY_F1
@defvrx {Constant} GLUT_KEY_F2
@defvrx {Constant} GLUT_KEY_F3
@defvrx {Constant} GLUT_KEY_F4
@defvrx {Constant} GLUT_KEY_F5
@defvrx {Constant} GLUT_KEY_F6
@defvrx {Constant} GLUT_KEY_F7
@defvrx {Constant} GLUT_KEY_F8
@defvrx {Constant} GLUT_KEY_F9
@defvrx {Constant} GLUT_KEY_F10
@defvrx {Constant} GLUT_KEY_F11
@defvrx {Constant} GLUT_KEY_F12
@defvrx {Constant} GLUT_KEY_LEFT
@defvrx {Constant} GLUT_KEY_UP
@defvrx {Constant} GLUT_KEY_RIGHT
@defvrx {Constant} GLUT_KEY_DOWN
@defvrx {Constant} GLUT_KEY_PAGE_UP
@defvrx {Constant} GLUT_KEY_PAGE_DOWN
@defvrx {Constant} GLUT_KEY_HOME
@defvrx {Constant} GLUT_KEY_END
@defvrx {Constant} GLUT_KEY_INSERT
@end defvr


@defun glut-mouse-func fn
@end defun

@defvr {Constant} GLUT_LEFT_BUTTON
@defvrx {Constant} GLUT_MIDDLE_BUTTON
@defvrx {Constant} GLUT_RIGHT_BUTTON
@defvrx {Constant} GLUT_DOWN
@defvrx {Constant} GLUT_UP
@end defvr

@defun glut-motion-func fn
@end defun

@defun glut-passive-motion-func fn
@end defun

@defun glut-entry-func fn
@end defun

@defvr {Constant} GLUT_LEFT
@defvrx {Constant} GLUT_ENTERED
@end defvr

@defun glut-visibility-func fn
@end defun

@defvr {Constant} GLUT_NOT_VISIBLE
@defvrx {Constant} GLUT_VISIBLE
@end defvr

@defun glut-idle-func fn
@end defun

@defun glut-timer-func millis fn value
@end defun

@defun glut-menu-state-func fn
@end defun

@defun glut-special-func fn
@end defun

@defun glut-spaceball-motion-func fn
@end defun

@defun glut-spaceball-rotate-func fn
@end defun

@defun glut-spaceball-button-func fn
@end defun

@defun glut-button-box-func fn
@end defun

@defun glut-dials-func fn
@end defun

@defun glut-tablet-motion-func fn
@end defun

@defun glut-tablet-button-func fn
@end defun

@defun glut-menu-status-func fn
@end defun

@defun glut-overlay-dislay-func fn
@end defun

@defun glut-window-status-func fn
@end defun

@defun glut-keyboard-up-func fn
@end defun

@defun glut-special-up-func fn
@end defun

@defun glut-joystick-func fn interval
@end defun

@c ----------------------------------------------------------------------
@node GLUT colormap, GLUT state retrieval, GLUT callbacks, GLUT API
@section GLUT colormap

@defun glut-set-color index r g b
@end defun

@defun glut-get-color index component
@end defun

@defvr {Constant} GLUT_RED
@defvrx {Constant} GLUT_GREEN
@defvrx {Constant} GLUT_BLUE
@end defvr

@defun glut-copy-colormap win
@end defun

@c ----------------------------------------------------------------------
@node GLUT state retrieval, GLUT font, GLUT colormap, GLUT API
@section GLUT state retrieval

@defun glut-get type
@end defun

@defvr {Constant} GLUT_WINDOW_X
@defvrx {Constant} GLUT_WINDOW_Y
@defvrx {Constant} GLUT_WINDOW_WIDTH
@defvrx {Constant} GLUT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_WINDOW_BUFFER_SIZE
@defvrx {Constant} GLUT_WINDOW_STENCIL_SIZE
@defvrx {Constant} GLUT_WINDOW_DEPTH_SIZE
@defvrx {Constant} GLUT_WINDOW_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_RED_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_GREEN_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_BLUE_SIZE
@defvrx {Constant} GLUT_WINDOW_ACCUM_ALPHA_SIZE
@defvrx {Constant} GLUT_WINDOW_DOUBLEBUFFER
@defvrx {Constant} GLUT_WINDOW_RGBA
@defvrx {Constant} GLUT_WINDOW_PARENT
@defvrx {Constant} GLUT_WINDOW_NUM_CHILDREN
@defvrx {Constant} GLUT_WINDOW_COLORMAP_SIZE
@defvrx {Constant} GLUT_WINDOW_NUM_SAMPLES
@defvrx {Constant} GLUT_WINDOW_STEREO
@defvrx {Constant} GLUT_WINDOW_CURSOR
@defvrx {Constant} GLUT_SCREEN_WIDTH
@defvrx {Constant} GLUT_SCREEN_HEIGHT
@defvrx {Constant} GLUT_SCREEN_WIDTH_MM
@defvrx {Constant} GLUT_SCREEN_HEIGHT_MM
@defvrx {Constant} GLUT_MENU_NUM_ITEMS
@defvrx {Constant} GLUT_DISPLAY_MODE_POSSIBLE
@defvrx {Constant} GLUT_INIT_WINDOW_X
@defvrx {Constant} GLUT_INIT_WINDOW_Y
@defvrx {Constant} GLUT_INIT_WINDOW_WIDTH
@defvrx {Constant} GLUT_INIT_WINDOW_HEIGHT
@defvrx {Constant} GLUT_INIT_DISPLAY_MODE
@defvrx {Constant} GLUT_ELAPSED_TIME
@defvrx {Constant} GLUT_WINDOW_FORMAT_ID
@end defvr

@defun glut-device-get type
@end defun

@defvr {Constant} GLUT_HAS_KEYBOARD
@defvrx {Constant} GLUT_HAS_MOUSE
@defvrx {Constant} GLUT_HAS_SPACEBALL
@defvrx {Constant} GLUT_HAS_DIAL_AND_BUTTON_BOX
@defvrx {Constant} GLUT_HAS_TABLET
@defvrx {Constant} GLUT_NUM_MOUSE_BUTTONS
@defvrx {Constant} GLUT_NUM_SPACEBALL_BUTTONS
@defvrx {Constant} GLUT_NUM_BUTTON_BOX_BUTTONS
@defvrx {Constant} GLUT_NUM_DIALS
@defvrx {Constant} GLUT_NUM_TABLET_BUTTONS
@defvrx {Constant} GLUT_DEVICE_IGNORE_KEY_REPEAT
@defvrx {Constant} GLUT_DEVICE_KEY_REPEAT
@defvrx {Constant} GLUT_HAS_JOYSTICK
@defvrx {Constant} GLUT_OWNS_JOYSTICK
@defvrx {Constant} GLUT_JOYSTICK_BUTTONS
@defvrx {Constant} GLUT_JOYSTICK_AXES
@defvrx {Constant} GLUT_JOYSTICK_POLL_RATE
@end defvr

@defun glut-extension-supported name
@end defun

@defun glut-get-modifiers 
@end defun

@defvr {Constant} GLUT_ACTIVE_SHIFT
@defvrx {Constant} GLUT_ACTIVE_CTRL
@defvrx {Constant} GLUT_ACTIVE_ALT
@end defvr

@defun glut-layer-get type
@end defun

@defvr {Constant} GLUT_OVERLAY_POSSIBLE
@defvrx {Constant} GLUT_LAYER_IN_USE
@defvrx {Constant} GLUT_HAS_OVERLAY
@defvrx {Constant} GLUT_TRANSPARENT_INDEX
@defvrx {Constant} GLUT_NORMAL_DAMAGED
@defvrx {Constant} GLUT_OVERLAY_DAMAGED
@end defvr

@c ----------------------------------------------------------------------
@node GLUT font, GLUT pre-built models, GLUT state retrieval, GLUT API
@section GLUT font

@deftp {Class} <glut-font>
@clindex glut-font
@end deftp

@defun glut-bitmap-character font character
@end defun

@defun glut-bitmap-width font character
@end defun

@defun glut-stroke-character font character
@end defun

@defun glut-stroke-width font character
@end defun

@defun glut-bitmap-length font string
@end defun

@defun glut-stroke-length font string
@end defun

@c ----------------------------------------------------------------------
@node GLUT pre-built models,  , GLUT font, GLUT API
@section GLUT pre-built models

@defun glut-wire-sphere radius slices stacks
@defunx glut-solid-sphere radius slices stacks
@end defun

@defun glut-wire-cone radius height slices stacks
@defunx glut-solid-cone radius height slices stacks
@end defun

@defun glut-wire-cube size
@defunx glut-solid-cube size
@end defun

@defun glut-wire-torus inner outer sides rings
@defunx glut-solid-torus inner outer sides rings
@end defun

@defun glut-wire-dodecahedron 
@defunx glut-solid-dodecahedron
@end defun

@defun glut-wire-teapot size
@defunx glut-soild-teapot size
@end defun

@defun glut-wire-octahedron
@defunx glut-solid-octahedron
@end defun

@defun glut-wire-tetrahedron
@defunx glut-solid-tetrahedron
@end defun

@defun glut-wire-icosahedron
@defunx glut-solid-icosahedron
@end defun


@c ======================================================================
@node Vectors and matrices, Indices, GLUT API, Top
@chapter Vectors and matrices

@deftp {Module} gl.math3d
@mdindex gl.math3d
The module provides vector and matrix operations useful for
3D computer graphics.

Actually this module itself doesn't depend on GL; you can use
this module alone to do matrix calculations.  However, the structure
of objects are designed so that they can be passed directly to
Gauche-gl functions, reducing the overhead of type conversions.

The purpose of this module is to provide reasonable performance.
So the operations are fixed to 3D homogeneous coordinates,
i.e. a vector is 4-element column vector, and a matrix is 4x4
square matrix.  If you want more flexibility, @code{<array>}
class in @code{gauche.array} provides much more generic
structures, trading performance.

Elements of vectors and matrices are represented in @code{float}
internally.   When you retrieve each element individually, 
it is converted to @code{double}, so you might see some precision
errors.   There are lots of operations directly manipulate group of
elements without retrieving each element to Scheme world, avoiding
overhead of conversion.
@end deftp

@c ----------------------------------------------------------------------
@menu
* Vectors and points::          
* Vector arrays and point arrays::  
* Matrices::                    
* Quaternions::                 
@end menu

@node Vectors and points, Vector arrays and point arrays, Vectors and matrices, Vectors and matrices
@section Vectors and points

@deftp {Class} <vector4f>
@deftpx {Class} <point4f>
@clindex vector4f
@clindex point4f
4x1 column vectors.  @code{Vector4f} is intended to be used
to represent a vector, and @code{point4f} is to a point,
but as far as OpenGL concerns, both are just an array of four floats,
@var{x}, @var{y}, @var{z} and @var{w}.

These classes inherit @code{<sequence>} and @code{<collection>}
classes.  So if you import @code{gauche.sequence} module,
you can use generic function such as @code{ref} and @code{(setter ref)}
to get/set individual elements.  The generic version of 
@code{map} and @code{for-each} can also be used on the vector4f and
point4f instances.

Aside from the type, 
the only difference is that the default value of @var{w} component---
it's 0.0 for vectors, and 1.0 for points.  So usual transformation
produces expected results; for example point plus vector
becomes point, vector plus vector becomes vector,
and translating point changes its coordinates but
translating vectors doesn't, and so on.
However, you can set @var{w} component to other value to do 
nontrivial operations.
@end deftp

@deftp {Reader syntax} @code{#,(vector4f @var{x} @var{y} @var{z} @var{w})}
@deftpx {Reader syntax} @code{#,(point4f @var{x} @var{y} @var{z} @var{w})}
These SRFI-10 syntax can be used to denote literal @code{<vector4f>}
and @code{<point4f>} instance, respectively.

The write methods are defined so that the instance is written out
in this form, and can be read back later.
@end deftp

@defun vector4f? obj
@defunx point4f? obj
Returns true iff @var{obj} is vector4f and point4f, respectively.
@end defun


@defun vector4f x y z &optional (w 0.0)
@defunx point4f x y z &optional (w 1.0)
Creates a vector4f and point4f instance with given values, respectively.
@end defun

@defun make-vector4f
@defunx make-point4f
Another way to create a vector4f and a point4f.
The first returns @code{#,(vector4f 0.0 0.0 0.0 0.0)},
and the latter returns @code{#,(point4f 0.0 0.0 0.0 1.0)}.
@end defun

@defun list->vector4f l
@defunx list->point4f l
Convert a list of three or four real numbers to a vector4f and a point4f,
respectively.
If @var{l} is not a list of three or four real numbers, an error is
signalled.

@example
(list->vector4f l)
  @equiv{} (apply vector4f l)
  @equiv{} (coerce-to <vector4f> l)
@end example
@end defun

@defun vector4f->list v
@defunx point4f->list p
Convert a vector4f and a point4f to a list of four real numbers,
respectively.

@example
(vector4f->list v)
  @equiv{} (coerce-to <list> v)
  @equiv{} (map (cut ref v <>) (iota 4))
@end example
@end defun

@defun f32vector->vector4f v &optional start
@defunx f32vector->point4f v &optional start
Creates a vector4f or a point4f, initializing by the elements of
f32vector @var{v}.   @var{V} must be longer than 4, and the first
four elements are used to initialize the created vector or point.

If optional @var{start} argument is given, it specifies an index
of @var{v} from which the initial values are taken; that is,
@var{start}, @var{start+1}, @var{start+2} and @var{start+3}-th
elements are used to create a vector or a point.
This allows to create vectors from plain float array:
@example
(map (lambda (off) (f32vector->vector4f vec (* off 4)))
     (iota (/ (size-of vec) 4)))
@end example

The conversion can be done using @code{coerce-to}, as well.
@example
(f32vector->vector4f vec)
  @equiv{} (coerce-to <vector4f> vec)
@end example
@end defun

@defun vector4f->f32vector v
@defunx point4f->f32vector p
Convert a vector4f @var{v} or a point4f @var{p} to four-element
f32vector.

@example
(vector4f->f32vector v)
 @equiv{} (coerce-to <f32vector> v)
@end example
@end defun

@defun vector4f-copy v
@defunx point4f-copy p
Returns a new copy of vector4f @var{v} or point4f @var{p}, respectively.
@end defun

@defun vector4f-copy! dstv srcv
@defunx point4f-copy! dstp srcp
Destructively sets the content of @var{srcv} or @var{srcp} to
@var{dstv} or @var{dstp}, respectively.
@end defun

@defun vector4f-set! v k value
@defunx point4f-set! p k value
Sets a real number @var{value} to
@var{k}-th element of a vector4f @var{v} or a point4f @var{p}.

@example
(vector4f-set! v k value)
  @equiv{} (set! (ref v k) value)
@end example
@end defun

@defun vector4f-ref v k &optional fallback
@defunx point4f-ref p k &optional fallback
Gets a value of @var{k}-th element of a vector4f @var{v} or
a point4f @var{p}.  If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-ref v k)
  @equiv{} (ref v k)
@end example
@end defun

@defun vector4f-dot x y
Returns a dot product of two vector4fs, @var{x} and @var{y}.
@end defun

@defun vector4f-cross x y
Returns a cross product of two vector4fs, @var{x} and @var{y}.
(@var{w} element is ignored).
@end defun

@defun vector4f-normalize x
@defunx vector4f-normalize! x
Returns a normalized vector of vector4f @var{x}.
@code{Vector4f-normalize} allocates a new vector, while
@code{vector4f-normalize!} modifies the original vector.

As a special case, 
if @var{x} is a vector of length 0, a vector of length 0 is returned.
@end defun

@defun vector4f-add x y
@defunx vector4f-sub x y
@defunx vector4f-add! x y
@defunx vector4f-sub! x y
Returns a sum of two vector4fs, @var{x} and @var{y}.
The destructive version modifies @var{x}.
@end defun

@defun point4f-add x y
@defunx point4f-add! x y
Adds a point4f @var{x} and a vector4f @var{y}, and returns
a translated point.  The destructive version modifies @var{x}.
@end defun

@defun point4f-sub x y
Subtracts either a vector4f or a point4f @var{y} from
a point4f @var{x}.  If @var{y} is a vector4f, returns 
a translated point.  If @var{y} is a point4f, returns
a vector4f from point @var{y} to point @var{x}.
@end defun

@c ----------------------------------------------------------------------
@node Vector arrays and point arrays, Matrices, Vectors and points, Vectors and matrices
@section Vector arrays and point arrays

@deftp {Class} <vector4f-array>
@deftpx {Class} <point4f-array>
@clindex vector4f-array
@clindex point4f-array
Represents an array of vector4fs and point4fs.
This is an efficient way to keep an array of vectors or points,
for the elements are packed in a simple float array.
They are especially useful to work with GL's vertex array feature.
@code{gl-vertex-pointer} can take @code{<point4f-array>},
and @code{gl-normal-pointer} can take @code{<vector4f-array>}.

It is also possible to "view" a plain f32vector as @code{<vector4f-array>}
or @code{<point4f-array>} without copying its content, by
@code{f32vector->vector4f-array/shared} and
@code{f32vector->point4f-array/shared}.   Combined to
@code{read-block!}, you can do efficient binary I/O of
vertex arrays, for example.

Inherits @code{<sequence>} and @code{<collection>}.
When viewed as a sequence or a collection, they behaves like
sequence or collection of @code{vector4f} and @code{point4f} objects,
respectively.
@end deftp

@defun make-vector4f-array len &optional init-vector
@defunx make-point4f-array len &optional init-point
Creates a vector4f-array or point4f-array with @var{len} elements.
Each element is initialized by a vector4f @var{init-vector} or
a point4f @var{init-point} if provided.
@end defun

@defun vector4f-array? obj
@defunx point4f-array? obj
Returns true iff @var{obj} is a vector4f-array or a point4f-array,
respectively.
@end defun

@defun vector4f-array-length array
@defunx point4f-array-length array
Returns length (number of vectors/points) in array @var{array}.
@end defun

@deftp {Reader syntax} @code{#,(vector4f-array @var{len} @var{elt} @dots{})}
@deftpx {Reader syntax} @code{#,(point4f-array @var{len} @var{elt} @dots{})}
Vector4f-array and point4f-array have external representation
using this SRFI-10 syntax.  @var{Len} is a length of array,
and each @var{elt} is a list of four floats representing
each element of the array.

@example
(f32vector->vector4f-array #f32(1 2 3 4 6 7 4 3))
  @result{} #,(vector4f-array 2 (1 2 3 4) (6 7 4 3) )
@end example
@end deftp

@defun list->vector4f-array list
@defunx list->point4f-array list
From given list of vector4fs or point4fs, creates and returns
a vector4f-array or point4f-array, respectively.
@end defun

@defun f32vector->vector4f-array v
@defunx f32vector->point4f-array v
Converts f32vector @var{v} to a vector4f-array or a point4f-array.
The length of @var{v} must be multiple of four.
The content of @var{v} is copied.

@example
(f32vector->vector4f-array v)
  @equiv{} (coerce-to <vector4f-array> v)
@end example
@end defun

@defun f32vector->vector4f-array/shared v
@defunx f32vector->point4f-array/shared v
Like above, but the content of @var{v} is shared by the result
array, instead of being copied.
So the modification of result array will be visible from original
f32vector @var{v} and vice versa.
It will allow efficient handling of large vertex arrays.
@end defun

@defun vector4f-array->f32vector array
@defunx point4f-array->f32vector array
Converts a vector4f-array or a point4f-array @var{array} to a f32vector.

@example
(vector4f-array->f32vector array)
  @equiv{} (coerce-to <f32vector> array)
@end example
@end defun

@defun vector4f-array-set! array i vector
@defunx point4f-array-set! array i point
Sets a vector4f @var{vector} or a point4f @var{point} to
@var{i}-th element of vector4f-array or point4f-array @var{array},
respectively.

@example
(vector4f-array-set! array i vector)
  @equiv{} (set! (ref array i) vector)
@end example
@end defun

@defun vector4f-array-ref array i &optional fallback
@defunx point4f-array-ref array i &optional fallback
Returns a vector4f or a point4f which is the @var{i}-th element
of array @var{array}, respectively.
If @var{k} is out of range,
an error is signalled, unless @var{fallback} is provided,
in such a case @var{fallback} is returned.

@example
(vector4f-array-ref array i)
  @equiv{} (ref array i)

(ref #,(vector4f-array 2 (1 2 3 4) (6 7 4 3))  1)
  @result{} #,(vector4f 6 7 4 3)
@end example
@end defun

@defun vector4f-array-ref/shared array i &optional fallback
@defunx point4f-array-ref/shared array i &optional fallback
Like above, but the returned vector4f or point4f shares the storage
with the original array.  Thus the modification of the result
vector or point will be visible from @var{array}, and vice versa.
@end defun

@c ----------------------------------------------------------------------
@node Matrices, Quaternions, Vector arrays and point arrays, Vectors and matrices
@section Matrices

@deftp {Class} <matrix4f>
@clindex matrix4f
4x4 matrix.  Internally it is represented as an array of 16 floats,
stored in column-major order.
(It is the same order OpenGL uses, so it can be passed to OpenGL
calls without overhead).

Inherits @code{<sequence>} and @code{<collection>}.
When a matrix4f is treated as a sequence, it works as if it is 
a single sequence of floats in column-major order.
@end deftp

@defun make-matrix4f &optional init
Returns a new matrix4f instance.  If @var{init} is omitted,
the matrix is a unit matrix.  Otherwise, @var{init} must be a f32vector
of length 16, and the elements in the matrix is initialized by
ones in f32vector.

@example
;; Creates a matrix like this:
;;    1 2 3 4
;;    0 1 0 5
;;    0 0 1 6
;;    0 0 0 1

(make-matrix4f '#f32vector(1 0 0 0
                           2 1 0 0
                           3 0 1 0
                           4 5 6 1))
@end example
@end defun

@defun matrix4f m00 m10 m20 m30 m01 m11 m21 m31 m02 m12 m22 m32 m03 m13 m23 m33
Creates a new matrix4f instance with give values.
@end defun

@defun matrix4f? obj
Returns true iff @var{obj} is a matrix4f.
@end defun

@deftp {Reader syntax} @code{#,(matrix4f @var{elt} @dots{})}
A matrix4f is represented extrenally using SRFI-10 syntax.
The elements are listed in column-major order.
@end deftp

@defun list->matrix4f l
@defunx matrix4f->list m
Converts between list of 16 real numbers and matrix4f.
@end defun

@defun f32vector->matrix4f v &optional start
Creates a new matrix4f and initializes it with 16 elements in
f32vector @var{v}.   If optional @var{start} is given,
it specifies the start offset in vector @var{v} to be used as
initial values.  The f32vector @var{v} must have enough length.
@end defun

@defun matrix4f->f32vector m
Returns a new f32vector that has elements from matrix4f @var{m}.
@end defun

@defun matrix4f-copy m
Returns a new copy of @var{m}.
@end defun

@defun matrix4f-copy! dstm srcm
Copies contents of @var{srcm} to @var{dstm}.
@end defun

@defun matrix4f-set! m i value
Sets a real number @var{value} to @var{i}-th element of matrix @var{m}.
Since the matrix is laid out in column-major order,
the one-dimensional index @code{m@{@var{i}@}} and two-dimensional
index @code{m(@var{i},@var{j})} corresponds as follows:
@example
  m(0,0) = m@{0@}   m(0,1) = m@{4@}   m(0,2) = m@{8@}   m(0,3) = m@{12@}
  m(1,0) = m@{1@}   m(1,1) = m@{5@}   m(1,2) = m@{9@}   m(1,3) = m@{13@}
  m(2,0) = m@{2@}   m(2,1) = m@{6@}   m(2,2) = m@{10@}  m(2,3) = m@{14@}
  m(3,0) = m@{3@}   m(3,1) = m@{7@}   m(3,2) = m@{11@}  m(3,3) = m@{15@}
@end example
@end defun

@defun matrix4f-ref m i &optional fallback
Returns the @var{i}-th element of matrix @var{m}.
If @var{i} is out of range, an error is signalled,
unless @var{fallback} is provided, in such a case
@var{fallback} is returned.
@end defun

@defun matrix4f-set2! m i j value
Sets @var{value} to @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-ref2 m i j
Returns the @code{(@var{i}, @var{j})} element of matrix @var{m}.
@end defun

@defun matrix4f-row m i
@defunx matrix4f-column m i
@defunx matrix4f-column/shared m i
Returns @var{i}-th row vector or @var{i}-th column vector
of matrix @var{m}, as a vector4f instance.

Furthermore, the returned vector from @code{matrix4f-column/shared}
shares the storage with @code{m}.
@end defun

@defun matrix4f-mul m obj
@var{Obj} may be a scalar (real number), a vector4f, a point4f, or a matrix4f.
Returns @var{m} x @var{obj}.
@end defun

@defun matrix4f-mul! m obj
@var{Obj} may be a scalar or a matrix4f.
Matrix @var{m} is multiplied by @var{obj}, and the result is
set to @var{m} destructively.
@end defun

@defun matrix4f-transpose m
@defunx matrix4f-transpose! m
Returns a transposed matrix of @var{m}.  The destructive version
modifies @var{m}.
@end defun

@defun matrix4f-determinant m
Returns a determinant of @var{m}.
@end defun

@defun matrix4f-inverse m &optional (error-on-singular? #t)
@defunx matrix4f-inverse! m &optional (error-on-singular? #t)
Returns a inverse matrix of @var{m}.  The destructive version
modifies @var{m}.  If given @var{m} is a singular matrix,
an error is signalled by default.  However, if @code{#f} is given
to the optional @var{error-on-singular?} argument,
@code{#f} is returned in such a case.
@end defun

@defun translation->matrix4f translation-vector
@defunx translation->matrix4f! m translation-vector
Returns a matrix which represents a translation by @var{translation-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.   Only the first three elements
in @var{translation-vector} is used.
The destructive version updates @var{m}.
@end defun

@defun rotation->matrix4f axis angle
@defunx rotation->matrix4f! m axis angle
Returns a matrix which represents a rotation around
@var{axis} by @var{angle} radian.  @var{Axis} must be
a vector4f or a f32vector of length 3 or 4, and must be normalized.
The result is undefined if anormalized vector is passed as @var{axis}.
The destructive version updates @var{m}.
@end defun

@defun scale->matrix4f scale-vector
@defunx scale->matrix4f! m scale-vector
Returns a matrix which represents a scale by @var{scale-vector},
which must be either a vector4f, a point4f, or
a f32vector of length 3 or 4.  Only the first three elements
in @var{scale-vector} is used.  Each element of @var{scale-vector}
represents the scale factor along x, y, and z axis.
The destructive version updates @var{m}.
@end defun

@defun trs->matrix4f translation rotation-axis rotation-angle scale
@defunx trs->matrix4f! m translation rotation-axis rotation-angle scale
This combines above three procedure.
Returns a matrix that represents translation, rotation and
scale, specified by @var{translation}, @var{rotation-axis},
@var{rotation-angle} and @var{scale}.
The destructive version updates @var{m}.

If @code{@i{T}}, @code{@i{R}} and @code{@i{S}}, are
the matrices that represent translation, rotation and scale, respectively,
then these procedures effectively calculates
a matrix @code{@i{TRS}}. 
@end defun

@defun tqs->matrix4f translation rotation-quat scale
@defunx tqs->matrix4f! m translation rotation-quat scale
A variation of @code{trs->matrix4f}.  Instead of axis and angle,
rotation is represented by a quaternion @var{rotation-quat}.
@xref{Quaternions}, for more details about quaternions.
@end defun

@defun euler-angle->matrxi4f xangle yangle zangle &optional order
@defunx euler-angle->matrxi4f! m xangle yangle zangle &optional order
Returns a matrix that represents rotation along x, y and z axis
by @var{xangle}, @var{yangle}, and @var{zangle}, respectively.

The order of rotation can be specified by the optional argument
@var{order}, which may be one of the symbols @code{xyz}, @code{xzy},
@code{yzx}, @code{yxz}, @code{zxy}, or @code{zyx}.  For example,
symbol @code{xyz} means rotation around x-axis, then y-axis, then
z-axis.  Thus, if we write each rotation as @i{Rx}, @i{Ry}, and
@i{Rz}, the returned matrix is @i{RzRyRx}.
The default value of @var{order} is @code{xyz}.

The desrtuctive version modifies @var{m}.
@end defun

@defun matrix4f-decompose m
Matrix @var{m} is a composition of translation, rotation, shear and
scale.  Suppose transformation is applied in the reverse order.
This procedure decompose @var{m} into each individual transformation.

Returns five values.
@itemize @bullet
@item
A flag to indicate if @var{m} is non-singular.
@item
A translation vector @var{t}, in vector4f.  The first three elements
of @var{t} are for x, y, and z translations.
@item
A rotation matrix @var{r}, in matrix4f.
This is an orthogonal matrix represents rotation component.
@item
A shear vector @var{h}, in vector4f.  The first three elements
of @var{h} are for xy, xz and yz shear factors.
@item
A scale vector @var{s}, in vector4f.  The first three elements
of @var{s} are fof x, y, and z scale factors.
@end itemize

If @var{m} is singular, certain part of rotation matrix can't 
be recovered.   In such a case, @var{r} becomes also singular matrix.

If the original matrix has negative scale factor in any of 
x, y, or z scale, the decomposed scale factor will have all negative
components.  The signs of elements of @var{r} are adjusted accordingly.

Due to the precision errors,
you will see small values appear in shear component even @var{m} is
pure TRS matrix.
@end defun

@defun matrix4f-decompose! m t r h s
Linear update version of @code{matrix4f-decompose}.
The result vectors and matrices are stored in @var{t}, @var{r}, @var{h}
and @var{s}.  The return value is a boolean value indicates
@var{m} is non-singular or not.
@end defun

@defun matrix4f->rotation m
From given orthogonal matrix @var{m}, extracts and returns
and rotation axis and angle, as a vector4f and a real number.
@end defun

@defun matrix4f->rotation! m v
Same as above, except the storage of vector4f @var{v} is reused
to store the result axis.
@end defun

@c ----------------------------------------------------------------------
@node Quaternions,  , Matrices, Vectors and matrices
@section Quaternions

@deftp {Class} <quatf>
@clindex quatf
Quaternions.   Internally quaternions are represented as just
an array of four floats; the first three are the vector component
and the last is the scalar component.

Inherits @code{<sequence>} and @code{<collection>}.  When viewed
as sequence, it is just like a vector of four floats.
@end deftp

@defun quatf? obj
Returns true iff @var{obj} is a quaternion.
@end defun

@deftp {Reader syntax} @code{#,(quatf @var{x} @var{y} @var{z} @var{w})}
External representation of quaternion
@i{x}@b{i}+@i{y}@b{j}+@i{z}@b{k}+@i{w}.
@end deftp

@defun make-quatf &optional axis (angle 0)
Returns a new unit quaternion that represents a rotation
around vector @var{axis} by @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@var{Axis} must be a unit vector; if @var{axis} is anormalized,
the result is undefined.

If both @var{axis} and @var{angle} is omitted,
@code{#,(quatf 0 0 0 1)} is returned.
@end defun

@defun quatf x y z w
Returns a new quaternion whose elements are initialized by
@var{x}, @var{y}, @var{z}, @var{w}.
@end defun

@defun list->quatf l
@defunx quatf->list q
Converts between a list of four real numbers and a quaternion.
@end defun

@defun f32vector->quatf x &optional start
Returns a new quaternion whose elements are initialized by
the first four elements of f32vector @var{x}.
If @var{start} is given, the initial value is taken
starting from @var{start}-th index in @var{x}.
@end defun

@defun quatf->f32vector q
Returns a new f32vector whose contents is the same as a quaternion @var{q}.
@end defun

@defun quatf-copy q
Returns a fresh copy of a quaternion @var{q}.
@end defun

@defun quatf-copy! dstq srcq
Copies contents of a quaternion @var{srcq} to a quaternion @var{dstq}.
@end defun

@defun rotation->quatf! quat axis angle
Sets a quaternion @var{quat} so that it represents a rotation
around a unit vector @var{axis} by angle @var{angle} radians.
@var{Axis} can be a vector4f, a point4f or 
a f32vector (only first three component is used).
@end defun

@defun quatf-add p q
@defunx quatf-add! p q
@defunx quatf-sub p q
@defunx quatf-sub! p q
Addition and subtraction of quaternions.  The destructive version
modifies the first argument.
@end defun

@defun quatf-scale q s
@defunx quatf-scale! q s
Multiplies a quaternion @var{q} by a scalar value @var{s}.
The destructive version modifies @var{q}.
@end defun

@defun quatf-mul p q
@defunx quatf-mul! p q
Multiply two quaternions @var{p} and @var{q}.
The destructive version modifies @var{p}.
@end defun

@defun quatf-conjugate q
Returns a conjugate of a quaternion @var{q}.
@end defun

@defun quatf-transform q p
Transforms a vector or a point @var{p} by quaternion @var{q},
that is, returns @var{qpq*}, where @var{q*} is a conjugate of @var{q}.

This procedure assumes @var{q} is normalized.

@var{P} can be a vector4f, a point4f or a f32vector
(only first three elements are used).
Returns the same type of object as @var{p}.
@end defun

@defun quatf-norm q
Returns norm of @var{q}.
@end defun

@defun quatf-normalize q
@defunx quatf-normalize! q
Returns normalized quaternion of @var{q}.
The destructive version modifies @var{q}.
@end defun

@defun quatf->matrix4f q
@defunx quatf->matrix4f! m q
Returns a matrix that represents a rotation specified by a unit
quaternion @var{q}.
The behavior is undefined if @var{q} is not normalized.
The destructive version modifies @var{m}.
@end defun

@defun quatf-slerp p q t
@defunx quatf-slerp! r p q t
Returns a quaternion that interpolates between two
unit quaternions @var{p} and @var{q}, by a scalar value @var{t}.
The destructive version modifies @var{t}.
@end defun




@c ======================================================================
@c @node GL-Scheme utility, Indices, 3D vectors and matrices, Top
@c @chapter GL-Scheme utility



@c ======================================================================
@node Indices,  , Vectors and matrices, Top
@appendix Indices
@c NODE 索引

@menu
* Function and Syntax Index::   
* Module Index::                
* Class Index::                 
* Variable Index::              
@end menu

@node Function and Syntax Index, Module Index, Indices, Indices
@appendixsec Function and Syntax Index
@c NODE 手続きと構文索引
@printindex fn

@node Module Index, Class Index, Function and Syntax Index, Indices
@appendixsec Module Index
@c NODE モジュール索引
@printindex md

@node Class Index, Variable Index, Module Index, Indices
@appendixsec Class Index
@c NODE クラス索引

For readability, the surrounding @code{<} and @code{>} are stripped off.

@printindex cl

@node Variable Index,  , Class Index, Indices
@appendixsec Variable Index
@c NODE 変数索引
@printindex vr


@contents
@bye

@c Local variables:
@c outline-regexp: "@chap\\|@unnu\\|@\\(sub\\)*section"
@c end:

